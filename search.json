[
  {
    "objectID": "ueberlappungen.html",
    "href": "ueberlappungen.html",
    "title": "Überlappungen vermeiden",
    "section": "",
    "text": "Hat man eine Visualisierung erstellt, sollte man sie sich immer nochmal genau anschauen und prüfen, ob sich Elemente überlappen und ob die Lesbarkeit eingeschränkt ist.\nEs ist immer schöner, wenn es möglichst keine verdeckten Datenpunkte gibt. Doch wenn wir große Datensätze visualisieren wollen, lässt es sich manchmal nicht so einfach vermeiden, dass Punkte übereinander liegen und sich überlappen. Selbst in kleineren Datensätzen kann das schon passieren, wenn Daten nicht präzise genug aufgezeichnet wurden und man mit gerundeten Werten arbeitet, sodass es viele Punkte mit genau dem gleichen Wert gibt. Dieses Problem wird auch “overplotting” genannt.\nZum Glück gibt es einige Strategien, mit denen wir solche Probleme lösen können und die wir in diesem Abschnitt erarbeiten. Dazu gehören:\n\nTransparente Datenpunkte\nJittering\nSmall Multiples\n\n\n\nTransparente Datenpunkte\nDieses hier erstelle Scatterplot soll uns die Verteilung der Attacken rechter Gewalt über die Jahre pro Zielgruppe zeigen:\n\n\nCode\nimport matplotlib.pyplot as plt\nimport pandas as pd\nimport numpy as np\n\n#Einlesen des Datensatzes\ndf = pd.read_excel('2023-rtv-1990-2022_without-sources.xlsx')\n \n# Gruppieren nach Jahr und Zielgruppe und Zählen der Vorfälle pro Jahr und Zielgruppe\nincident_counts = df.groupby(['year', 'grouped_target_group']).size().reset_index(name='incident_count')\n \n# Scatterplot erstellen\nplt.figure(figsize=(7.5, 6))\n \n# Scatterplot für die Anzahl der Vorfälle pro Jahr und Zielgruppe\nfor target_group in incident_counts['grouped_target_group'].unique():\n    group_data = incident_counts[incident_counts['grouped_target_group'] == target_group]\n    plt.scatter(\n        group_data['year'],\n        group_data['incident_count'],\n        label=target_group\n    )\n \n# Achsenbeschriftungen und Titel hinzufügen\nplt.xlabel('Jahr')\nplt.ylabel('Anzahl der Attacken')\nplt.title('Anzahl der Attacken pro Jahr pro Zielgruppe', fontsize=15)\nplt.legend(title='Zielgruppen', loc=\"upper left\", fontsize=10)\n \n# Plot anzeigen\nplt.show()\n\n\n\n\n\nAnzahl der Attacken pro Jahr und Zielgruppe\n\n\n\n\nLeider überlappen sich viele Punkte im unteren Bereich, sodass man das Diagramm nur schwer lesen kann.\nEin effektiver Weg um insbesondere Überlappungen in Scatterplots zu vermeiden, ist die Anpassung der Transparenz von Datenpunkten. Indem wir Punkte teilweise transparent setzen, erscheinen überlappende Bereiche dunkler und geben uns so einen visuellen HInweis darauf, wo Datenpunkte häufig auftreten.\n\n\nCode\nimport matplotlib.pyplot as plt\nimport pandas as pd\nimport numpy as np\n\n#Einlesen des Datensatzes\ndf = pd.read_excel('2023-rtv-1990-2022_without-sources.xlsx')\n \n# Gruppieren nach Jahr und Zielgruppe und Zählen der Vorfälle pro Jahr und Zielgruppe\nincident_counts = df.groupby(['year', 'grouped_target_group']).size().reset_index(name='incident_count')\n \n# Scatterplot erstellen\nplt.figure(figsize=(7.5, 6))\n \n# Scatterplot für die Anzahl der Vorfälle pro Jahr und Zielgruppe\nfor target_group in incident_counts['grouped_target_group'].unique():\n    group_data = incident_counts[incident_counts['grouped_target_group'] == target_group]\n    plt.scatter(\n        group_data['year'],\n        group_data['incident_count'],\n        alpha=0.5, # Anpassung der Transparenz\n        label=target_group\n    )\n \n# Achsenbeschriftungen und Titel hinzufügen\nplt.xlabel('Jahr')\nplt.ylabel('Anzahl der Attacken')\nplt.title('Anzahl der Attacken pro Jahr pro Zielgruppe', fontsize=15)\nplt.legend(title='Zielgruppen', loc=\"upper left\", fontsize=10)\n \n# Plot anzeigen\nplt.show()\n\n\n\n\n\nAnzahl der Attacken pro Jahr und Zielgruppe\n\n\n\n\nMit dem Parameter alpha lässt sich der Grad an Transparenz festlegen, dieser ist ein float zwischen 0 und 1. Dabei bedeutet 0 komplett transparent und 1 deckend gefärbt. Hier haben wir alpha=0.5 gewählt.\n\n\n\nJittering\nDurch Transparenz lassen sich leider nicht immer alle Probleme lösen und kann es trotzdem noch schwer sein zu erkennen, wie viele Punkte genau übereinander liegen. Einen einfachen Trick, den man hier anwenden kann, ist das sogenannte “Jittering”. Dabei werden die Punkte leicht in zufällige Richtungen verschoben, was die Lesbarkeit verbessert.\n\n\nCode\nimport matplotlib.pyplot as plt\nimport pandas as pd\nimport numpy as np\n\n#Einlesen des Datensatzes\ndf = pd.read_excel('2023-rtv-1990-2022_without-sources.xlsx')\n\n# Gruppieren nach Jahr und Zielgruppe und Zählen der Vorfälle pro Jahr und Zielgruppe\nincident_counts = df.groupby(['year', 'grouped_target_group']).size().reset_index(name='incident_count')\n\n# Scatterplot erstellen\nplt.figure(figsize=(7.5, 6))\n\n# Jitter-Stärke\njitter_strength = 0.1\n\n# Scatterplot für die Anzahl der Vorfälle pro Jahr und Zielgruppe\nfor target_group in incident_counts['grouped_target_group'].unique():\n    group_data = incident_counts[incident_counts['grouped_target_group'] == target_group]\n    jittered_year = group_data['year'] + np.random.uniform(-jitter_strength, jitter_strength, size=len(group_data))\n    jittered_count = group_data['incident_count'] + np.random.uniform(-jitter_strength, jitter_strength, size=len(group_data))\n    plt.scatter(\n        jittered_year,\n        jittered_count, \n        alpha=0.5,\n        label=target_group\n    )\n\n# Achsenbeschriftungen und Titel hinzufügen\nplt.xlabel('Jahr')\nplt.ylabel('Anzahl der Attacken')\nplt.title('Anzahl der Attacken pro Jahr und Zielgruppe', fontsize=15)\nplt.legend(title='Zielgruppen', loc=\"upper left\", fontsize=10)\n\n# Plot anzeigen\nplt.show()\n\n\n\n\n\nAnzahl der Attacken pro Jahr und Zielgruppe\n\n\n\n\nHier haben wir dem Scatterplot die Variable jitter_strength = 0.1 hinzugefügt, die die Stärke des Jitterings bestimmt. Wir können diesen Wert auch anpassen um mehr oder weniger Jittering zu bekommen.\nFür jeden Punkt im Scatterplot wird dann eine zufällige Verschiebung zu den x- und y-Koordinaten hinzugefügt. Dafür benutzen wir np.random.uniform um Zufallswerte im Bereich [-jitter_strength, jitter_strength] zu erzeugen, die mit den Daten addiert werden.\nJittering sollte aber immer mit Vorsicht verwendet werden, da es Daten verändert. Jittern wir zu viel, können Punkte an Stellen landen, an die sie nicht hingehören und somit den Datensatz nicht mehr repräsentieren, was irreführend sein kann.\n\n\n\nSmall Multiples\nAuch bei Liniendiagrammen kann es schnell zu Überlappungen kommen, wenn zu viele Kategorien betrachtet werden.\nDies ist ein Liniendiagramm, das uns zeigen soll, wie viele Attacken es jedes Jahr in verschiedenen Ländern gab, um einen Überblick über die Veränderung im Laufe der Jahre zu erhalten:\n\n\nCode\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\n\n#Der Datensatz\ndf = pd.read_excel('2023-rtv-1990-2022_without-sources.xlsx')\n\n\n# Anzahl der Attacken pro Land und Jahr gruppieren\nattack_counts = df.groupby(['year', 'country_name']).size().reset_index(name='attack_count')\n\n#Liste der Länder aus den Daten extrahieren \ncountries = df['country_name'].unique()\n\n#Größe der Visualisierung\nplt.figure(figsize=(7.5, 6))\n\n# Für jedes Land, plotte die Attacken über die Jahre\nfor country in countries:\n    country_data = attack_counts[attack_counts['country_name'] == country]\n    plt.plot(country_data['year'], country_data['attack_count'], label=country)\n\n# Achsenbeschriftungen und Titel hinzufügen\nplt.ylabel('Anzahl der Attacken')\nplt.title('Anzahl der Attacken pro Jahr und pro Land')\nplt.legend(fontsize=8)\n\n# Zeigt das gesamte Diagramm an\nplt.show()\n\n\n\n\n\nAnzahl der Attacken pro Land und Jahr\n\n\n\n\nDas dabei entstandene Liniendiagramm sieht ziemlich chaotisch aus, da sich alles überschneidet und es zu viele Länder gibt, sodass diese durch die Farben kaum unterschieden werden können.\nUm die Daten lesbarer zu machen eignet sich eine Darstellung mithilfe von “Small Multiples” viel besser, also ein Raster an kleinen einzelnen Diagrammen.\n\n\nCode\nimport matplotlib.pyplot as plt\nimport pandas as pd\nimport numpy as np\n\n#Der Datensatz\ndf = pd.read_excel('2023-rtv-1990-2022_without-sources.xlsx')\n\n\n#Small Multiples für Anzahl der Attacken\nimport matplotlib.pyplot as plt\n\n#Anzahl der Attacken pro Land berechnen\nattack_counts = df.groupby(['year', 'country_name']).size().reset_index(name='attack_count')\n\n#Liste der Länder aus den Daten extrahieren \ncountries = df['country_name'].unique()\n\n#Anzahl der Länder\nnum_countries = len(countries)\n\n#Subplots erstellen\n#Hier erstellen wir ein 6x3 Raster von Subplots, um so ein Plot pro Land zu erhalten\n#sharey= True und sharex=True bedeutet, dass die Achsen zwischen den Plots alle gleich sind\nfig, axes = plt.subplots(6, 3, figsize=(15, 12), sharey= True, sharex = True)\n\n#Flachmachen des 2D-Arrays von Achsen in ein 1D-Array für einfacheren Zugriff\naxes = axes.flatten() \n\n#Iteriere über jedes Land und erstelle einen separaten Plot\nfor i, country in enumerate(countries):\n    country_data = attack_counts[attack_counts['country_name'] == country]\n    axes[i].plot(country_data['year'], country_data['attack_count'], label=country)\n    axes[i].set_title(country)\n    axes[i].set_xlabel('Jahr')\n    axes[i].set_ylabel('Anzahl der Attacken')\n    axes[i].grid(True)\n\n#Überschrift\nplt.suptitle(\"Anzahl der Attacken pro Jahr und pro Land\", fontsize=15)\nplt.title(\" \")\n\n#Optimierung des Layouts, um Überlappungen zu vermeiden und die Abstände anzupassen\nplt.tight_layout()\n\n#Zeigt das gesamte Diagramm an\nplt.show()\n\n\n\n\n\nAnzahl der Attacken pro Land und Jahr\n\n\n\n\nHier haben wir jetzt mithilfe von fig, axes = plt.subplots(6, 3, figsize=(20, 15), sharey=True, sharex=True) ein Raster an kleinen Subplots pro Land erstellt. Die Zahl 6 bedeutet, dass wir 6 Zeilen haben möchten und die 3 ist die Anzahl der gewollten Spalten, da wir 18 verschiedene Länder zeigen möchten. Die Parameter sharey=True und sharex=True sorgen dafür, dass alle Subplots dieselben Achsen teilen, was den Vergleich erleichtert. Dies hat aber auch Nachteile, wenn es Länder mit besonders niedrigen und Länder mit besonders hohen Werten gibt, es lohnt sich auf jeden Fall beides auszuprobieren.\nIm restlichen Code wird dann mit einer for-Schleife für jedes Land ein eigener Plot, mit den jeweiligen Daten und zugehörigen Achsenbeschriftungen, erstellt. Mithilfe von plt.tight_layout() können wir dann das Layout anpassen, um ungleichmäßige Abstände zu vermeiden.\nDurch diese Art der Darstellung ist jede Linie klar erkennbar und für jedes Land voneinander getrennt, was Überlappungen vermeidet und die Lesbarkeit der Daten verbessert.",
    "crumbs": [
      "Startseite",
      "Gestaltung",
      "Überlappungen vermeiden"
    ]
  },
  {
    "objectID": "text.html",
    "href": "text.html",
    "title": "Beschriftungen",
    "section": "",
    "text": "Es gibt verschiedene Arten von Beschriftungen in einem Diagramm, dazu gehören zum Beispiel Achsenbeschriftungen, Titel und Legenden, die wir jeweils individualisieren können.\n\n\nText und Beschriftungen einfügen\nDie Titel und Achsenbeschriftungen können mit folgenden Funktionen jeweils angepasst werden:\n\nplt.title(\"Der Titel\")\nplt.xlabel(\"Beschriftung der x-Achse\")\nplt.ylabel(\"Beschriftung der y-Achse\")\n\nAußerdem können wir auch einen Untertitel hinzufügen, dafür benutzen wir zunächst plt.suptitle('Der Haupttitel') für den Haupttitel. Mit plt.title('Der Untertitel') wird dann der Untertitel hinzugefügt.\nUm in einer Visualisierung Text an einer bestimmten Stelle einzufügen können wir mithilfe von plt.text(x, y, \"beliebiger Text\") einen beliebigen Text in Form eines Strings an die Stellen x, y hinzufügen.\n\n\nCode\nimport matplotlib.pyplot as plt\nimport pandas as pd\n\n#Einlesen des Datensatzes\ndf = pd.read_excel('2023-rtv-1990-2022_without-sources.xlsx')\n\n# Filtern der Daten für Deutschland\ndf_germany = df[df['country_name'] == 'Germany']\n\n# Zählen der Angriffe pro Jahr\nattacks_per_year = df_germany.groupby('year').size().reset_index(name='attack_count')\n\n# Erstellen des Balkendiagramms\nplt.figure(figsize=(7.5, 6))\nbars = plt.bar(attacks_per_year['year'], attacks_per_year['attack_count'], color='coral')\n\n# Hinzufügen von Beschriftungen und Titel\nplt.xlabel('Jahre')\nplt.ylabel('Anzahl der Attacken')\nplt.title('Anzahl der Attacken pro Jahr in Deutschland', fontsize=16)\n\n# Finden des höchsten Balkens und Hinzufügen von Text\nmax_value = attacks_per_year['attack_count'].max()\nmax_year = attacks_per_year[attacks_per_year['attack_count'] == max_value]['year'].values[0]\nplt.text(max_year, max_value, \"das ist der höchste Balken\", ha='center')\n\n# Anzeigen des Diagramms\nplt.tight_layout()\nplt.show()\n\n\n\n\n\nAnzahl der Attacken pro Jahr in Deutschland mit eingefügtem Text\n\n\n\n\nDieses Diagramm zeigt uns die Anzahl der Attacken pro Jahr in Deutschland, zudem haben wir an dem höchsten Balken noch einen Text eingefügt. Dies funktioniert mit der Funktion plt.text(max_year, max_value, \"das ist der höchste Balken\", ha='center'). Die Variablen max_year und max_value sind die Koordinaten des höchsten Balkens, an dem wir den Text haben wollen. Mithilfe von ha='cneter' haben wir noch die Position angepasst, sodass der Text mittig erscheint.\n\n\n\nBeschriftungen rotieren\nUm Beschriftungen für eine bessere Lesbarkeit zu rotieren können wir die Funktion plt.xticks() mit dem Parameter rotation verwenden.\n\n\nCode\nimport matplotlib.pyplot as plt\nimport pandas as pd\n\n#Einlesen des Datensatzes\ndf = pd.read_excel('2023-rtv-1990-2022_without-sources.xlsx')\n\n# Filtern der Daten für Deutschland\ndf_germany = df[df['country_name'] == 'Germany']\n\n# Zählen der Angriffe pro Jahr\nattacks_per_year = df_germany.groupby('year').size().reset_index(name='attack_count')\n\n# Erstellen des Balkendiagramms\nplt.figure(figsize=(7.5, 6))\nbars = plt.bar(attacks_per_year['year'], attacks_per_year['attack_count'], color='coral')\n\n# Hinzufügen von Beschriftungen und Titel\nplt.xlabel('Jahre')\nplt.ylabel('Anzahl der Attacken')\nplt.suptitle('Anzahl der Attacken pro Jahr in Deutschland', fontsize=20)\nplt.title('Rotierte Beschriftungen')\n\n# Anpassung der x-Achse Ticks und Beschriftungen\nplt.gca().set_xticks(attacks_per_year['year'][::2]) # EIn Strich alle 2 Jahre\nplt.xticks(rotation=45) # Rotieren um 45 Grad\n\n# Anzeigen des Diagramms\nplt.tight_layout()\nplt.show()\n\n\n\n\n\nAnzahl der Attacken pro Jahr in Deutschland\n\n\n\n\nIn diesem Diagramm haben wir die x-Achsenbeschriftung mit plt.xticks(rotation=45) um 45 Grad rotiert, um die Jahreszahlen lesbarer zu gestalten.\n\n\n\nDie Legende\nEine verständliche und lesbare Legende ist sehr wichtig. Mit plt.legend() können wir eine Legende erstellen, die automatisch an die beste Stelle gesetzt wird, sodass sie die Daten nicht verdeckt.\nWenn wir die Legende an einer anderen Stelle haben wollen, können wir den Paramter loc verwenden: plt.legend(loc=\"lower left\"). Dabei können wir loc Werte wie \"upper\", \"lower\", \"center\", \"left\", und \"right\" übergeben, um die Position anzupassen. Die automatisch voreingestellte Position ohne Parameter ist übrigens identisch zu plt.legend(loc=\"best\").\n\n\nCode\nimport matplotlib.pyplot as plt\nimport pandas as pd\n\n#Einlesen des Datensatzes\ndf = pd.read_excel('2023-rtv-1990-2022_without-sources.xlsx')\n \n# Gruppieren nach Jahr und Zielgruppe und Zählen der Attacken pro Jahr und Zielgruppe\nincident_counts = df.groupby(['year', 'grouped_target_group']).size().reset_index(name='incident_count')\n \n# Scatterplot erstellen\nplt.figure(figsize=(7.5, 6))\n \n# Scatterplot für die Anzahl der Vorfälle pro Jahr und Zielgruppe\nfor target_group in incident_counts['grouped_target_group'].unique():\n    group_data = incident_counts[incident_counts['grouped_target_group'] == target_group]\n    plt.scatter(\n        group_data['year'],\n        group_data['incident_count'],\n        alpha=0.6, \n        label=target_group\n    )\n \n# Achsenbeschriftungen und Titel hinzufügen\nplt.xlabel('Jahr')\nplt.ylabel('Anzahl der Attacken')\nplt.title('Anzahl der Attacken pro Jahr und Zielgruppe', fontsize=15)\n\n#Hinzufügen der Legende \nplt.legend(title='Zielgruppen', loc=\"upper left\", fontsize=10)\n \n# Plot anzeigen\nplt.show()\n\n\n\n\n\nAnzahl der Attacken pro Jahr und Zielgruppe\n\n\n\n\nIn diesem Scatterplot haben wir die Anzahl der Attacken pro Zielgruppe und Land visualisiert. Mithilfe von plt.legend(title='Zielgruppen', loc=\"upper left\", fontsize=10) haben wir dann eine Legende mit Titel, angepasster Position und Schriftgröße eingefügt.\n\n\n\nSchriftarten und Größen\nDurch den Parameter fontsize kann die Schriftgröße von Text angepasst werden. Um die Schriftart zu ändern können wir dem Parameter family einen String mit dem Namen einer Schriftart übergeben.\n\n\nCode\nimport matplotlib.pyplot as plt\nimport pandas as pd\n\n# Einlesen des Datensatzes\ndf = pd.read_excel('2023-rtv-1990-2022_without-sources.xlsx')\n\n# Berechne die Anzahl der Attacken pro Zielgruppe\ntarget_group_counts = df['grouped_target_group'].value_counts().reset_index()\ntarget_group_counts.columns = ['grouped_target_group', 'attack_count']\n\n# Erstellen des Balkendiagramms mit einer Colormap\nplt.figure(figsize=(6.5, 5))\nplt.barh(target_group_counts['grouped_target_group'], target_group_counts['attack_count'], color=plt.cm.Set2(range(len(target_group_counts))))\n\n# Hinzufügen von Beschriftungen und Titel\nplt.xlabel('Anzahl der Attacken', fontsize=16, family='monospace')\nplt.ylabel('Zielgruppen', fontsize=16, family='cursive')\nplt.title('Anzahl der Attacken pro Zielgruppe in Westeuropa', fontsize=20, family='fantasy')\n\n# Anzeigen des Diagramms\nplt.tight_layout()\nplt.show()\n\n\n\n\n\nAnzahl der Attacken pro Zielgruppe\n\n\n\n\nHier haben wir ein Diagramm mit verschiedenen Schriftgrößen und Schriftarten erstellt, dabei können wir die Parameter fontsize und family allen Text-Funktionen übergeben.\nGlobal kann die Schrift für das gesamte Jupyter-Notebook auch mit plt.rc(\"font\", family=\"serif\", size=20) angepasst werden, dann haben alle Texte in unseren Visualisierungen die gleichen Schriftanpassungen.\nEs gibt auch noch ganz viele weitere Schriftarten, hier befindet sich eine Liste mit Beispielen.",
    "crumbs": [
      "Startseite",
      "Gestaltung",
      "Beschriftungen"
    ]
  },
  {
    "objectID": "scatterPlot.html",
    "href": "scatterPlot.html",
    "title": "Scatter Plots",
    "section": "",
    "text": "Scatter Plots, auch bekannt als Punktwolken oder Streudiagramme, eignen sich besonders für die Untersuchung von Beziehungen oder Korrelationen zwischen zwei Variablen. Auch Ausreißer können gut identifiziert werden, weil man direkt erkennen kann, wenn ein Punkt weit vom Rest der Daten entfernt ist. Im Unterschied zu Liniendiagrammen, die Trends über eine kontinuierliche Variable darstellen, zeigen sie, wie sich einzelne Datenpunkte in Bezug auf zwei Variablen verteilen.\n\nGrundsätzliche Struktur eines Scatter Plots\nDas folgende Beispiel zeigt die grundlegende Struktur eines einfachen Scatter Plots:\n\n\nCode\nimport matplotlib.pyplot as plt\n\n# Beispiel-Daten\nx = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\ny = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]\n\n# Scatterplot erstellen\nplt.scatter(x, y)\n\n# Achsenbeschriftungen und Titel hinzufügen (optional)\nplt.xlabel('X-Achse')\nplt.ylabel('Y-Achse')\nplt.title('Einfaches Scatterplot-Beispiel')\n\n# Plot anzeigen\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\nBeispiel anhand des RTV-Datensatzes\nIn diesem Beispiel vergleichen wir die Zahl der Fälle in den drei Ländern mit den meisten Fällen rechter Gewalt über die Jahre hinweg. Für diese Darstellung wäre prinzipiell ein Liniendiagramm auch geeignet: Der Scatterplot ermöglicht es uns aber, die Datenpunkte für jedes Land getrennt zu visualisieren.\n\n\nCode\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Dateipfad zur Excel-Datei\nfile_path = '2023-rtv-1990-2022_without-sources.xlsx'\n\n# Lese Excel-Datei ein\ndf = pd.read_excel(file_path, engine='openpyxl')\n\n# Gruppieren nach Jahr und Land und Zählen der Vorfälle\nincident_counts = df.groupby(['country_name', 'year']).size().reset_index(name='incident_count')\n\n# Berechnen der Gesamtanzahl der Vorfälle pro Land\ntotal_incidents_per_country = incident_counts.groupby('country_name')['incident_count'].sum().reset_index()\n\n# Finden der fünf Länder mit den meisten Vorfällen\ntop_5_countries = total_incidents_per_country.nlargest(3, 'incident_count')['country_name']\n\n# Filtere die Daten für die fünf Länder mit den meisten Vorfällen\ntop_5_data = incident_counts[incident_counts['country_name'].isin(top_5_countries)]\n\nfor i, country in enumerate(top_5_countries):\n    country_data = top_5_data[top_5_data['country_name'] == country]\n    plt.scatter(country_data['year'], country_data['incident_count'], label=country)\n\n# Achsenbeschriftungen und Titel hinzufügen\nplt.xlabel('Year')\nplt.ylabel('Number of Incidents')\nplt.title('Number of Incidents per Year for Top 3 Countries')\nplt.legend(title='Country', bbox_to_anchor=(1.05, 1), loc='upper left')\n\n# Plot anzeigen\nplt.show()",
    "crumbs": [
      "Startseite",
      "Wahl der Visualisierung",
      "Scatter Plots"
    ]
  },
  {
    "objectID": "pieChart.html",
    "href": "pieChart.html",
    "title": "Pie Charts",
    "section": "",
    "text": "Pie Charts, oder auch Kreisdiagramme, sind ein beliebtes Werkzeug zur Darstellung von Proportionen, vor allem wenn es darum geht prozentuale Verteilungen von Kategorien darzustellen. Sie begegnen einem im Alltag oft, aber in der Wissenschaft wird eher von der Verwendung abgeraten: Das menschliche Auge kann aus ihnen die Proportionen nicht präzise erkennen. Der Vollständigkeit halber sollen sie aber trotzdem vorgestellt werden.\n\nGrundsätzliche Struktur eines Kreisdiagramms\nDas folgende Beispiel zeigt, wie ein einfaches Kreisdiagramm erstellt wird. Die Prozentangaben sind optional, werden aber empfohlen, um die Lesbarkeit und das Verständnis der dargestellten Daten zu verbessern.\n\n\nCode\nimport matplotlib.pyplot as plt\n\n# Daten für das Pie Chart\nlabels = ['Kategorie A', 'Kategorie B', 'Kategorie C']\nsizes = [40, 35, 25]  # Die Prozentwerte der Kategorien\n\n# Erstellen des Pie Charts\nplt.pie(sizes, labels=labels, autopct='%1.1f%%')\n\n# Hinzufügen von Titel\nplt.title('Verteilung der Kategorien')\n\n# Anzeigen des Diagramms\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\nBeispiel anhand des RTV-Datensatzes\nHier haben wir die Frage gestellt, wie die Verteilung der Target Groups der Angriffe ist. Wichtig beim Erstellen von Kreisdiagrammen ist die Vermeidung von zu vielen Kategorien. “Unknown” und “Other” - im Datensatz separate Kategorien - wurden deshalb zur besseren Lesbarkeit gruppiert.\n\n\nCode\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Dateipfad\nfile_path = '2023-rtv-1990-2022_without-sources.xlsx'\n\n# Lese Excel-Datei ein\ndf = pd.read_excel(file_path, engine='openpyxl')\n\n# Ersetzen von \"Unknown\" und \"Other\" durch \"Unknown/Other\"\ndf['grouped_target_group'] = df['grouped_target_group'].replace(['Unknown', 'Other'], 'Unknown/Other')\n\n# Häufigkeit der Kategorien in der Spalte 'grouped_target_group' berechnen\ntarget_group_counts = df['grouped_target_group'].value_counts()\n\n# Erstellen des Pie Charts\nplt.pie(target_group_counts, labels=target_group_counts.index, autopct='%1.1f%%', startangle=140)\n\n# Hinzufügen von Titel\nplt.title('Verteilung der Zielgruppen')\n\n# Anzeigen des Diagramms\nplt.show()\n\n\n\n\n\n\n\n\n\nMan kann anhand der Visualisierung erkennen, dass die meisten Angriffsopfer der Gruppe “Ethnic/religious minorities” zugeordnet wurden.",
    "crumbs": [
      "Startseite",
      "Wahl der Visualisierung",
      "Pie Charts"
    ]
  },
  {
    "objectID": "lizenz.html",
    "href": "lizenz.html",
    "title": "Lizenz",
    "section": "",
    "text": "Für die Materialien auf dieser Website werden CC BY 4.0 Nutzungsrechte bereitgestellt. Sie erhalten dadurch das Recht, die Materialien unentgeltlich zu nutzen und weiterzuverwenden, sofern Sie die Herkunft entsprechend zitieren.\nBitte zitieren Sie diese Lernressource wie folgt: Brandner, Lisa; Jurk, Inka; Mauermann, Johanna: Daten sichtbar machen. Einführung in die Datenvisualisierung mit Python, Johannes-Gutenberg-Universität Mainz 2024."
  },
  {
    "objectID": "kapitel4.html",
    "href": "kapitel4.html",
    "title": "Wahl der Visualisierung",
    "section": "",
    "text": "Wir haben den Datensatz ausgewählt und erfolgreich eingelesen. Nun geht es an die Visualisierung der Daten, doch wie kommt man dorthin? Es existiert eine geradezu endlose Auswahl an verschiedenen Plots und Diagrammen. Hier gibt es einen umfassenden Überblick für die Möglichkeiten mit matplotlib. Diese Vielfalt kann für Anfänger schnell überfordernd sein, wenn man im Grunde noch keine wirkliche Idee hat, wie man überhaupt eine Visualisierung erstellt, und anhand welcher Kriterien man die richtige Art der Darstellung auswählt.\n\n\nWelche Darstellung eignet sich wofür?\nNicht jede Art der Visualisierung ist für alles gleichermaßen gut geeignet. Oft wählt man besser eine einfache Option, die möglichst wenig den Blick von den Daten – die ja der Hauptprotagonist sein sollten – ablenkt.\nBei der Wahl der Visualisierung sollten zudem beachtet werden:\n\nArt der Daten: Es gilt zu bestimmen, ob die Daten qualitativ oder quantitativ bzw. kategorisch oder numerisch sind. Zum Beispiel eignen sich Balkendiagramme gut für kategorische Daten, während Liniendiagramme oft für zeitliche Trends verwendet werden.\nZiel der Visualisierung: Geht es einem um die Veranschaulichung von Trends und Entwicklungen? Den Vergleich von Datenpunkten? Das Aufzeigen von Verteilungen oder Proportionen? Abhängig vom Ziel der Visualisierung, eignen sich verschiedene Darstellungen besser oder schlechter.\n\nMan sollte sich also anhand der Frage, was man zeigen möchte, überlegen, wie man es zeigen möchte, d.h. welche Visualisierung man auswählt.\n\n\n\nVerschiedene Plots und Diagramme\nIn den folgenden Kapiteln gibt es einen Überblick über ein paar gängige Arten von Plots und Diagrammen, die mithilfe der matplotlib-Bibliothek erstellt werden können. Dazu werden Hinweise geliefert, für was für Darstellungen und Fragestellungen diese besonders geeignet sein könnten.\n\nLine Charts\nBar Charts\nKreisdiagramme\nScatter Plots\nHistogramme\nBoxplots\nHeatmaps",
    "crumbs": [
      "Startseite",
      "Wahl der Visualisierung"
    ]
  },
  {
    "objectID": "kapitel1.html",
    "href": "kapitel1.html",
    "title": "Daten vorbereiten",
    "section": "",
    "text": "Am Anfang jeder Datenvisualisierung stehen die Daten selbst. Häufig liegen sie jedoch in einer Form vor, in der wir nicht ungehindert mit ihnen arbeiten können. Stattdessen ist meist noch viel Arbeit nötig, bevor die erste Visualisierung umsetzbar ist.\n\n\nOpen Refine\nFür das Einlesen und Verarbeiten tabellarischer Daten stehen zahlreiche Optionen zur Verfügung. In den Geisteswissenschaften erfreut sich unter anderem die open source Software OpenRefine, die einen sinnvollen Kompromiss zwischen nutzerfreundlicher Handhabung und umfangreichen Funktionen bietet, großer Beliebtheit. OpenRefine stellt eine optische click-and-play Umgebung zur Verfügung, bietet eine Verlaufsanzeige, die Möglichkeit Daten über das Web zu akquirieren (reconsiling) und vieles mehr. Aber OpenRefine kann nicht alles, den funktionalen Möglichkeiten sind Grenzen gesetzt.\n\n\n\nPython Pandas\nSpätestens, wenn andere Softwareangebote nicht mehr weiterkommen, sollten wir an Python denken. Mit Python haben wir eine mächtige Programmiersprache in den Händen, die sich durch einen nutzerfreundlichen Einstieg verdient gemacht hat. Auch wenn Python mehr Vorkenntnisse erfordert und keine optische Nutzerumgebung bereithält, liegt der Vorteil auf der Hand: Python kann nahezu alles. Unserer Datenaufbereitung sind keine Grenzen mehr gesetzt und wir können von Datenbereinigung, über KI-gestützte Analyse bis zur Visualisierung alles in einer Entwicklungsumgebung umsetzen.\nIn Python steht für die Verarbeitung tabellarischer Daten eine umfangreiche Bibliothek zur Verfügung: pandas. In den folgenden Abschnitten werden wir in die Datenverarbeitung mit pandas einführen. Eine vollständige Dokumentation von pandas bietet zum Beispiel die w3school pandas documentation.",
    "crumbs": [
      "Startseite",
      "Daten vorbereiten"
    ]
  },
  {
    "objectID": "impressum.html",
    "href": "impressum.html",
    "title": "Impressum",
    "section": "",
    "text": "Diese Website ist im Zuge des Seminars Erarbeitung Schulungsmaterialien, unter Leitung von Dr. Franziska Klemstein im Sommersemester 2024 an der Johannes-Gutenberg-Universität Mainz entstanden.\nAutoren: Lisa Brandner, Inka Jurk und Johanna Mauermann\nKontaktieren Sie uns unter: someone@somewhere.de"
  },
  {
    "objectID": "heatmap.html",
    "href": "heatmap.html",
    "title": "Heatmaps",
    "section": "",
    "text": "Eine Heatmap ist eine grafische Darstellung von Daten, bei der individuelle Werte in einer Matrix durch Farben dargestellt werden. Sie eignet sich besonders gut, um Muster oder Korrelationen in großen Datensätzen zu erkennen, da sie es ermöglicht, auf einen Blick Zusammenhänge zu visualisieren. Clusterbildung und Anomalien in Datensätzen können mit ihrer Hilfe identifiziert werden.\n\n\nBestandteile einer Heatmap\n\nFarben: Die Hauptkomponente der Heatmap, die den Wertebereich der Daten repräsentiert. Unterschiedliche Farbschattierungen zeigen die Intensität der Werte an, wobei häufig eine Farbskala verwendet wird.\nAchsenbeschriftungen: Geben Kontext zu den dargestellten Daten und ermöglichen es, spezifische Zellen innerhalb der Heatmap zu identifizieren.\nFarblegende: Erklärt die Bedeutung der Farben und hilft dabei, die dargestellten Daten korrekt zu interpretieren.\n\n\n\n\nGrundsätzliche Struktur einer Heatmap\nIm folgenden Beispiel wird eine einfache Heatmap erstellt, die die Häufigkeit von Ereignissen in verschiedenen Kategorien und Zeiträumen darstellt.\n\n\nCode\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Beispiel-Daten: Eine Matrix von Zahlen\ndata = {\n    'Category A': [1, 2, 3],\n    'Category B': [4, 5, 6],\n    'Category C': [7, 8, 9]\n}\n\n# Erstelle ein DataFrame\ndf = pd.DataFrame(data, index=['Row 1', 'Row 2', 'Row 3'])\n\n# Erstelle eine Heatmap\nplt.figure(figsize=(8, 5))\nplt.imshow(df, cmap='viridis', aspect='auto')\n\n# Füge Farbbalken hinzu\nplt.colorbar(label='Value')\n\n# Setze die Achsenbeschriftungen\nplt.xticks(range(len(df.columns)), df.columns, rotation=45)\nplt.yticks(range(len(df.index)), df.index)\n\n# Füge Beschriftungen für die Achsen und den Titel hinzu\nplt.xlabel('Category')\nplt.ylabel('Row')\nplt.title('Simple Heatmap Example')\n\n# Annotieren der Heatmap\nfor i in range(df.shape[0]):\n    for j in range(df.shape[1]):\n        plt.text(j, i, df.iloc[i, j], ha='center', va='center', color='white')\n\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\nBeispiel anhand des RTV-Datensatzes\nIn dieser Heatmap wird die Anzahl der Fälle pro Jahr und Target Group der Angriffe visualisiert, wodurch man schnell erkennen kann, in welchen Kategorien und Zeiträumen die meisten Ereignisse aufgetreten sind.\n\n\nCode\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Dateipfad \nfile_path = '2023-rtv-1990-2022_without-sources.xlsx'\n\n# Excel-Datei einlesen \ndf = pd.read_excel(file_path, engine='openpyxl')\n\n# Gruppiere die Daten nach Jahr und Zielgruppe und zähle die Vorkommen\ngrouped_df = df.groupby(['year', 'grouped_target_group']).size().unstack(fill_value=0)\n\n# Erstelle eine Heatmap\nplt.figure(figsize=(12, 8))\nplt.imshow(grouped_df, cmap='plasma', aspect='auto')\n\n# Füge Farbbalken hinzu\nplt.colorbar(label='Count')\n\n# Setze die Achsenbeschriftungen\nplt.xticks(range(len(grouped_df.columns)), grouped_df.columns, rotation=45)\nplt.yticks(range(len(grouped_df.index)), grouped_df.index)\n\n# Füge Beschriftungen für die Achsen und den Titel hinzu\nplt.xlabel('Grouped Target Group')\nplt.ylabel('Year')\nplt.title('Heatmap of Target Groups per Year')\n\n# Annotieren der Heatmap\nfor i in range(grouped_df.shape[0]):\n    for j in range(grouped_df.shape[1]):\n        plt.text(j, i, grouped_df.iloc[i, j], ha='center', va='center', color='white')\n\nplt.show()",
    "crumbs": [
      "Startseite",
      "Wahl der Visualisierung",
      "Heatmaps"
    ]
  },
  {
    "objectID": "formen_linien.html",
    "href": "formen_linien.html",
    "title": "Formen und Linien",
    "section": "",
    "text": "Formen und Linienanpassungen in Diagrammen helfen uns, Daten klarer und ansprechender darzustellen. Mit verschiedenen Linienarten und Formen können wir wichtige Informationen hervorheben und verschiedene Kategorien leicht unterscheiden.\n\n\nFormen\nFormen können bei der Datenpunktmarkierung eine Rolle spielen.\nMit dem Parameter marker kann das Aussehen eines Datenpunktes angepasst werden und mit markersize die Größe. Dabei erwartet markersize einen numerischen Wert und marker einen speziellen String, der die Form definiert.\n\nBeispiele verschiedener Punktmarker\n\n\nString\nBeschreibung\n\n\n\n\n\".\"\nPunkt\n\n\n\"o\"\nKreis\n\n\n\"*\"\nStern\n\n\n\"s\"\nRechteck\n\n\n\nEs gibt noch viel mehr Arten von Punktmarkern die hier gefunden werden können.\n\n\nCode\nimport matplotlib.pyplot as plt\nimport pandas as pd\n\n#Einlesen des Datensatzes\ndf = pd.read_excel('2023-rtv-1990-2022_without-sources.xlsx')\n\n# Gruppieren nach Jahr und Land und Zählen der Vorfälle\nincident_counts = df.groupby(['country_name', 'year']).size().reset_index(name='incident_count')\n\n# Berechnen der Gesamtanzahl der Vorfälle pro Land\ntotal_incidents_per_country = incident_counts.groupby('country_name')['incident_count'].sum().reset_index()\n\n# Finden der drei Länder mit den meisten Vorfällen\ntop_3_countries = total_incidents_per_country.nlargest(3, 'incident_count')['country_name']\n\n# Filtere die Daten für die drei Länder mit den meisten Vorfällen\ntop_3_data = incident_counts[incident_counts['country_name'].isin(top_3_countries)]\n\n# Verschiedene Punktformen für die Länder definieren\nmarkers = ['o', 's', '^']  # (Kreis, Quadrat, Dreieck)\n\n# Scatterplot erstellen\nplt.figure(figsize=(7.5, 7))\n\n# Hinzufügen von mehr Achsenstrichen\nplt.minorticks_on()\n\n#Jedem Land wird eine unterschiedliche Form zugewiesen\nfor i, (country, marker) in enumerate(zip(top_3_countries, markers)):\n    country_data = top_3_data[top_3_data['country_name'] == country] # Filtern der Daten \n    plt.scatter(country_data['year'], country_data['incident_count'], label=country, marker=marker) # Erstellen des Scatterplots mit jeweiliger Form und Land\n\n# Achsenbeschriftungen und Titel hinzufügen\nplt.xlabel('Jahr')\nplt.ylabel('Anzahl der Attacken')\nplt.title('Top 3 Länder mit den meisten Attacken')\nplt.legend()\n\n# Plot anzeigen\nplt.show()\n\n\n\n\n\nTop 3 Länder mit den meisten Attacken\n\n\n\n\nDieses Scatterplot zeigt uns die drei Länder mit den meisten Attacken, dabei haben wir jedem Land eine andere Form zugewiesen. Mit markers = ['o', 's', '^'] haben wir eine Liste an Formen erstellt, die wir dann in der for-Schleife einem Land zuweisen.\n\n\n\nLinien\nDer Parameter linestyle nimmt einen String, der den Strichstil einer Linie definiert. Der Parameter linewidth nimmt einen numerischen Wert, der die Linienbreite definiert.\n\nListe verschiedener Linienarten\n\n\nString\nBeschreibung\n\n\n\n\n\"solid\"\nDurchgezogen\n\n\n\"dashed\"\nGestrichelt\n\n\n\"dotted\"\nGepunktet\n\n\n\"dashdot\"\nStriche und Punkte abwechselnd\n\n\n\nNoch mehr über Linienarten kann hier gefunden werden.\n\n\nCode\nimport matplotlib.pyplot as plt\nimport pandas as pd\n\n#Einlesen des Datensatzes\ndf = pd.read_excel('2023-rtv-1990-2022_without-sources.xlsx')\n\n# Gruppieren nach Jahr und Zählen der Gesamtanzahl der Vorfälle pro Jahr\nincident_counts = df.groupby('year').size().reset_index(name='incident_count')\n \n# Scatterplot erstellen\nplt.figure(figsize=(7.5, 6))\n\n# Darstellen der Linie mit Anpassungen\nplt.plot(incident_counts['year'], incident_counts['incident_count'], color='mediumslateblue', linestyle='dashed', linewidth=2.5)\n \n# Achsenbeschriftungen und Titel hinzufügen\nplt.xlabel('Jahr')\nplt.ylabel('Anzahl der Attacken')\nplt.title('Anzahl der Attacken pro Jahr', fontsize=15)\n \n# Plot anzeigen\nplt.show()\n\n\n\n\n\nAnzahl der Attacken pro Jahr mit angepasster Linie\n\n\n\n\nIn dem Beispiel haben wir mithilfe von plt.plot(incident_counts['year'], incident_counts['incident_count'], color='mediumslateblue', linestyle='dashed', linewidth=3) ein Liniendiagramm erstellt, in dem wir die Farbe, den Stil und die Breite angepasst haben, um die Anzahl der Attacken pro Jahr darzustellen.\nLinien können auch in einem Scatterplot integriert werden, um Datenpunkte miteinander zu verbinden:\n\n\nCode\nimport matplotlib.pyplot as plt\nimport pandas as pd\n\n#Einlesen des Datensatzes\ndf = pd.read_excel('2023-rtv-1990-2022_without-sources.xlsx')\n\n# Gruppieren nach Jahr und Zählen der Gesamtanzahl der Vorfälle pro Jahr\nincident_counts = df.groupby('year').size().reset_index(name='incident_count')\n \n# Scatterplot erstellen\nplt.figure(figsize=(7.5, 6))\n \n# Scatterplot für die Anzahl der Vorfälle pro Jahr\nplt.scatter(incident_counts['year'], incident_counts['incident_count'], color='darkorange', zorder=2)\n\n# Eine Linie, die alle Datenpunkte verbindet\nplt.plot(incident_counts['year'], incident_counts['incident_count'], color='peachpuff', zorder=1)\n \n# Achsenbeschriftungen und Titel hinzufügen\nplt.xlabel('Jahr')\nplt.ylabel('Anzahl der Attacken')\nplt.title('Anzahl der Attacken pro Jahr', fontsize=15)\n \n# Plot anzeigen\nplt.show()\n\n\n\n\n\nAnzahl der Attacken pro Jahr mit Linien\n\n\n\n\nIn diesem Scatterplot haben wir mithilfe der Funktion plt.plot(incident_counts['year'], incident_counts['incident_count'], color='peachpuff', zorder=1) Linien hinzugefügt, um die Datenpunkte miteinander zu verbinden. Dabei übergibt man der Funktion plt.plot() die gleichen Daten wie dem Scatterplot. Alle anderen Parameter sind optional, wie zum Beispiel das Anpassen der Farbe mit color='peachpuff', zusätzlich kann man hier auch mit den oben beschriebenen Parametern linestyle und linewidth arbeiten. Wir haben hier außerdem die Linie unter die Datenpunkte gesetzt, dies geschieht mit dem Parameter zorder, welchen man einmal der Scatterplot-Funktion plt.scatter() und der Linien-Funktion plt.plot() übergibt. Der Parameter bekommt dann eine Zahl, die die Reihenfolge anzeigt.",
    "crumbs": [
      "Startseite",
      "Gestaltung",
      "Formen und Linien"
    ]
  },
  {
    "objectID": "einlesen.html",
    "href": "einlesen.html",
    "title": "Datensatz einlesen",
    "section": "",
    "text": "Bevor wir unsere Forschungsfragen an den Datensatz richten und mit den ersten Visualisierungen beginnen, müssen wir uns mit den Daten selbst beschäftigen. Zum Einlesen unserer Datensätze nutzen wir in Python die Bibliothek pandas.\n\n\nPandas laden und Dataframe einlesen\nDa die pandas Bibliothek nicht in den Standardbibliotheken von Python enthalten ist, muss sie zunächst nachgeladen werden:\n\n# Die pandas Bibliothek muss nachgeladen werden:\nimport pandas as pd\n\nAnschließend können die Daten eingelesen werden. Pandas kann alle tabellarischen Datenformate einlesen, in unserem Beispiel handelt es sich um eine Excel-Datei. Diese Excel-Datei überführen wir mit Hilfe von pandas in einen Dataframe (im Folgenden df genannt).\n\ndf = pd.read_excel('2023-rtv-1990-2022_without-sources.xlsx') \n# wenn sich das Dokument nicht im Projektordnder befindet, \n# muss an dieser Stelle der komplette Pfad angegeben werden.\n\n\n\n\nÜberblick über die Daten\nMit den Funktionen head() und tail() können wir uns anzeigen lassen, ob der Import der Daten tatsächlich funktioniert hat. Dabei zeigt head() uns die ersten und tail() die letzten Einträge der Tabelle an.\n\n# als Parameter können wir die Anzahl der Zeilen übergeben, \n# die wir angezeigt bekommen wollen.\ndf.head(2)\n\n\n\n\n\n\n\n\n\ncase_id\nyear\nmonth\nday\ncountry_id\niso3\ncountry_name\nregion\ncity/village\nlocation\n...\nweapon_type_2\ngrouped_weapon_type_2\nweapon_description\nfatal\nn_killed\nn_wounded\ndescription\nplot_type\nplot_targeting\nplot_operational_planning\n\n\n\n\n0\n1990-3-4\n1990\n3\n4\n13\nNOR\nNorway\nOslo\nOslo\nNaN\n...\nNaN\nNaN\nCS-gas\n0\n0\nm\nUnknown perpetrators threw a military grenade ...\nNaN\nNaN\nNaN\n\n\n1\n1990-4-21\n1990\n4\n21\n13\nNOR\nNorway\nNaN\nFevik\nNaN\n...\n600.0\nBeating/kicking\nSticks, chains, bats and beating/kicking\n0\n0\n5\nThe attack known as 'Fevik-slaget' occurred wh...\nNaN\nNaN\nNaN\n\n\n\n\n2 rows × 34 columns\n\n\n\n\n\n\n\nÜberblick über die Formatierung\nEinen Überblick über die Formatierung der einzelnen Spalten verschaffen wir uns mit der Funktion info(). Sie gibt für jede Spalte die Summe der Einträge mit NaN (= “Not a Number”, also nicht-definierte oder nicht-darstellbare Werte) und nicht-NaN Werten sowie das Datenformat aus.\n\ndf.info()\n\n&lt;class 'pandas.core.frame.DataFrame'&gt;\nRangeIndex: 2001 entries, 0 to 2000\nData columns (total 34 columns):\n #   Column                        Non-Null Count  Dtype  \n---  ------                        --------------  -----  \n 0   case_id                       2001 non-null   object \n 1   year                          2001 non-null   int64  \n 2   month                         2001 non-null   object \n 3   day                           2001 non-null   object \n 4   country_id                    2001 non-null   int64  \n 5   iso3                          2001 non-null   object \n 6   country_name                  2001 non-null   object \n 7   region                        1795 non-null   object \n 8   city/village                  2001 non-null   object \n 9   location                      1744 non-null   object \n 10  location_latitude             1604 non-null   object \n 11  location_longitude            1604 non-null   object \n 12  location_accuracy             1601 non-null   object \n 13  incident_type                 2001 non-null   int64  \n 14  perpetrator_type              2001 non-null   int64  \n 15  organizational_affiliation    558 non-null    object \n 16  organizational_affiliation_2  76 non-null     object \n 17  loneactor_id                  558 non-null    float64\n 18  target_group                  2001 non-null   int64  \n 19  grouped_target_group          2001 non-null   object \n 20  target_group_2                203 non-null    float64\n 21  grouped_target_group_2        203 non-null    object \n 22  weapon_type                   2001 non-null   int64  \n 23  grouped_weapon_type           2001 non-null   object \n 24  weapon_type_2                 546 non-null    float64\n 25  grouped_weapon_type_2         546 non-null    object \n 26  weapon_description            2001 non-null   object \n 27  fatal                         2001 non-null   int64  \n 28  n_killed                      2001 non-null   int64  \n 29  n_wounded                     2001 non-null   object \n 30  description                   2001 non-null   object \n 31  plot_type                     114 non-null    float64\n 32  plot_targeting                114 non-null    float64\n 33  plot_operational_planning     114 non-null    float64\ndtypes: float64(6), int64(8), object(20)\nmemory usage: 531.6+ KB\n\n\n\n\n\nÜberblick über die Statistik\nFür statistische Erhebungen stehen in pandas zahlreiche Funktionen zur Verfügung. Mit describe() können wir uns statistische Berechnungen ausgeben lassen. Für jede Spalte mit numerischem Datentyp erhalten wir die folgenden Angaben:\ncount: die Anzahl der nicht-NaN Werte\nmean: den Mittelwert\nstd: die Standardabweichung auf diese Spalten\nmin: der kleinsten Wert. Der Wert, unter dem 0% der gesamten Werte liegen\n25%: 0,25-Quantil. Der Wert, unter dem 25% der gesamten Werte liegen\n50%: 0,50-Quantil. Der Wert, unter dem 50% der gesamten Werte liegen\n75%: 0,75-Quantil. Der Wert, unter dem 75% der gesamten Werte liegen\nmax: der größten Wert. Der Wert, unter dem 100% der gesamten Werte liegen\n\ndf.describe()\n\n\n\n\n\n\n\n\n\nyear\ncountry_id\nincident_type\nperpetrator_type\nloneactor_id\ntarget_group\ntarget_group_2\nweapon_type\nweapon_type_2\nfatal\nn_killed\nplot_type\nplot_targeting\nplot_operational_planning\n\n\n\n\ncount\n2001.000000\n2001.000000\n2001.000000\n2001.000000\n558.000000\n2001.000000\n203.000000\n2001.000000\n546.000000\n2001.000000\n2001.000000\n114.000000\n114.000000\n114.000000\n\n\nmean\n2013.347326\n9.741129\n1.737131\n12.122439\n241.568100\n186.215392\n272.842365\n463.623688\n520.534799\n0.115442\n0.180410\n3.131579\n5.280702\n4.149123\n\n\nstd\n8.490336\n5.002295\n0.738150\n24.369315\n160.610029\n187.506317\n222.343114\n197.020125\n176.563858\n0.319635\n1.800815\n1.265702\n12.697647\n12.755171\n\n\nmin\n1990.000000\n1.000000\n1.000000\n1.000000\n1.000000\n100.000000\n100.000000\n100.000000\n100.000000\n0.000000\n0.000000\n1.000000\n1.000000\n1.000000\n\n\n25%\n2011.000000\n6.000000\n1.000000\n4.000000\n87.000000\n102.000000\n102.000000\n302.000000\n401.000000\n0.000000\n0.000000\n2.000000\n2.000000\n2.000000\n\n\n50%\n2016.000000\n7.000000\n2.000000\n6.000000\n240.500000\n102.000000\n204.000000\n502.000000\n580.000000\n0.000000\n0.000000\n3.000000\n3.000000\n2.000000\n\n\n75%\n2019.000000\n15.000000\n2.000000\n8.000000\n382.750000\n200.000000\n301.000000\n600.000000\n600.000000\n0.000000\n0.000000\n4.000000\n5.000000\n3.000000\n\n\nmax\n2022.000000\n18.000000\n4.000000\n99.000000\n521.000000\n900.000000\n900.000000\n900.000000\n900.000000\n1.000000\n77.000000\n5.000000\n99.000000\n99.000000\n\n\n\n\n\n\n\n\n Wie wir sehen, ist die Ausgabe für unser Beispiel wenig aussagekräftig, da die meisten numerischen Werte in unseren Daten nicht sinnvoll akkumuliert werden können.",
    "crumbs": [
      "Startseite",
      "Daten vorbereiten",
      "Datensatz einlesen"
    ]
  },
  {
    "objectID": "datenschutz.html",
    "href": "datenschutz.html",
    "title": "Datenschutz",
    "section": "",
    "text": "Verantwortlicher für die Erhebung, Verarbeitung und Nutzung Ihrer personenbezogenen Daten im Sinne von Art. 4 Nr. 7 DSGVO ist\nJohannes-Gutenberg Universität\nSarrstr. 21\n55122 Mainz\nGermany\n\n\nBetroffenenrechte: Rechte auf Auskunft, Berichtigung, Sperre, Löschung und Widerspruch\nSie haben das Recht, auf Antrag unentgeltlich eine Auskunft über die bei uns gespeicherten personenbezogenen Daten anzufordern und/oder eine Berichtigung, Sperrung oder Löschung zu verlangen. Eine Sperrung oder Löschung kann nicht erfolgen, wenn gesetzliche Regelungen dem entgegenstehen.\nBitte kontaktieren Sie unseren Datenschutzbeauftragten unter: datenschutz@uni-mainz.de\n\n\n\nDatenvermeidung und Datensparsamkeit\nWir speichern gemäß den Grundsätzen der Datenvermeidung und Datensparsamkeit personenbezogene Daten nur so lange, wie dies erforderlich ist oder vom Gesetzgeber vorgeschrieben wird. Erfassung allgemeiner Informationen\nInformationen zu einem Zugriff auf unsere Website werden durch unseren Provider automatisiert erfasst und in Form von Logfiles gespeichert. Die Logfiles sind von allgemeiner Natur und erlauben keine Rückschlüsse auf Ihre Person. Die Logfiles werden von uns nicht archiviert.\nSofern Logfiles erstellt werden, können unter anderem folgende Datenarten erfasst werden:\nBrowsertyp und Browserversion\nVerwendetes Betriebssystem\nBesuchte Seiten und Inhalte\nÜbertragene Datenmengen\nVerweisende Seite (Referrer URL)\nDatum und Uhrzeit Ihres Zugriffs\nanonymisierte IP-Adresse\n\n\n\nCookies\nDiese Website verwendet keine Cookies."
  },
  {
    "objectID": "boxplot.html",
    "href": "boxplot.html",
    "title": "Box Plots",
    "section": "",
    "text": "Ein Boxplot, auch bekannt als Kastendiagramm, ist ein statistisches Diagramm, das die Verteilung numerischer Daten darstellt. Es hebt die wichtigsten Quartile der Daten hervor und zeigt potenzielle Ausreißer auf. Boxplots sind nützlich, um Unterschiede zwischen mehreren Gruppen oder Datensätzen zu vergleichen und bieten eine schnelle visuelle Einschätzung der Verteilung, Symmetrie und Streuung der Daten.\n\n\nBestandteile eines Boxplots\n\nBox: Der Bereich zwischen dem ersten Quartil (Q1) und dem dritten Quartil (Q3) wird als Box dargestellt. Dieser Bereich, auch als Interquartilsabstand (IQR) bezeichnet, umfasst die mittleren 50% der Daten.\nMedian: Eine Linie innerhalb der Box zeigt den Median (Q2) der Daten an, also den mittleren Wert, wenn die Daten sortiert sind.\nWhiskers: Die “Whiskers” sind Linien, die von der Box nach außen verlaufen. Sie erstrecken sich bis zum Minimum und Maximum der Daten innerhalb einer bestimmten Grenze, typischerweise 1,5-mal des IQR.\n\nAusreißer: Datenpunkte, die außerhalb des Whiskers liegen, werden oft als individuelle Punkte dargestellt und gelten als potenzielle Ausreißer.\n\n\n\n\nEinfaches Beispiel für einen Boxplot\n\n\nCode\nimport matplotlib.pyplot as plt\n\n# Beispiel-Daten\ndata = [7, 8, 9, 5, 6, 8, 7, 5, 4, 8, 9, 6, 5, 8, 7]\n\n# Boxplot erstellen\nplt.boxplot(data)\n\n# Achsenbeschriftungen und Titel hinzufügen (optional)\nplt.xlabel('Sample Data')\nplt.ylabel('Values')\nplt.title('Simple Boxplot Example')\n\n# Plot anzeigen\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\nBeispiel anhand des RTV-Datensatzes\nIm folgenden Beispiel werden Unterschiede in der Verteilung tödlicher und nicht-tödlicher Fälle über die Jahre hinweg für die verschiedenen Länder untersucht:\n\n\nCode\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Dateipfad zur Excel-Datei\nfile_path = '2023-rtv-1990-2022_without-sources.xlsx'\n\n# Lese Excel-Datei ein\ndf = pd.read_excel(file_path, engine='openpyxl')\n\n# Erstelle ein Plot-Objekt mit einer spezifischen Größe\nfig, ax = plt.subplots(figsize=(15, 6))\n\n# Definiere Farben für die Boxplots: Blau für nicht-tödliche (0), Rot für tödliche (1) Fälle\ncolors = {0: 'blue', 1: 'red'}\n\n# Liste aller Länder aus der 'country_name'-Spalte\ncountries = df['country_name'].unique()\n\n# Durchlaufe alle Länder\nfor country in countries:\n    # Durchlaufe alle eindeutigen Werte in der 'fatal'-Spalte (0 oder 1)\n    for fatal in df['fatal'].unique():\n        # Filtere die Daten für das aktuelle Land und den aktuellen 'fatal'-Wert\n        subset = df[(df['country_name'] == country) & (df['fatal'] == fatal)]\n        \n        # Berechne die Position für den Boxplot:\n        # - Index des Landes in der Liste + 0.2 für tödliche Fälle, -0.2 für nicht-tödliche Fälle\n        positions = [list(countries).index(country) + (0.2 if fatal == 1 else -0.2)]\n        \n        # Erstelle den Boxplot für das gefilterte Daten-Subset\n        ax.boxplot(subset['year'], positions=positions, widths=0.4, patch_artist=True,\n                   boxprops=dict(facecolor=colors[fatal], color=colors[fatal]),\n                   medianprops=dict(color='yellow'), showfliers=True,\n                   flierprops=dict(markerfacecolor=colors[fatal], marker='o', markersize=12, linestyle='none'))\n\n# Setze die X-Achsen-Ticks auf die Anzahl der Länder\nax.set_xticks(range(len(countries)))\n# Setze die X-Achsen-Beschriftungen auf die Länderliste, rotiert um 45 Grad\nax.set_xticklabels(countries, rotation=45)\n\n# Setze den Titel und die Beschriftungen für die Achsen\nax.set_title('Boxplot: Fatal and Non-Fatal Cases by Country and Year')\nax.set_xlabel('Country')\nax.set_ylabel('Year')\n\n# Erstelle eine Legende mit den Farben und Beschriftungen für tödliche und nicht-tödliche Fälle\nax.legend(handles=[plt.Line2D([0], [0], color=color, lw=4) for color in colors.values()],\n          labels=['Non-Fatal', 'Fatal'])\n\n# Zeige den Plot\nplt.show()",
    "crumbs": [
      "Startseite",
      "Wahl der Visualisierung",
      "Box Plots"
    ]
  },
  {
    "objectID": "achsen_groesse.html",
    "href": "achsen_groesse.html",
    "title": "Achsenanpassungen",
    "section": "",
    "text": "Um Daten anschaulich darzustellen, brauchen wir meistens eine x- und eine y-Achse. Dabei verläuft die x-Achse waagerecht und die y-Achse senkrecht, gemeinsam bilden diese unser Koordinatensystem. Wie man diese Achsen anpassen kann, lernen wir jetzt in diesem Abschnitt.\n\n\nWahl des Achsenbereichs\nEine sinnvolle Wahl des Achsenbereichs ist sehr wichtig. Der darzustellende Bereich wird von matplotlib auf beiden Achsen automatisch gewählt, aber wir können, je nachdem, was wir in unseren Visualisierungen zeigen wollen, auch festlegen, wie weit diese Achsen reichen. Dann wird alles, was außerhalb dieses Bereichs liegt, nicht angezeigt.\nMit der Funktion plt.xlim(left, right) kann der Bereich auf der x-Achse und mit plt.ylim(bottom, top) der Bereich auf der y-Achse festgelegt werden.\n\n\nCode\nimport matplotlib.pyplot as plt\nimport pandas as pd\n\n#Einlesen des Datensatzes\ndf = pd.read_excel('2023-rtv-1990-2022_without-sources.xlsx')\n\n# Filtern der Daten für Deutschland\ndf_germany = df[df['country_name'] == 'Germany']\n\n# Zählen der Angriffe pro Jahr\nattacks_per_year = df_germany.groupby('year').size().reset_index(name='attack_count')\n\n# Erstellen des Balkendiagramms\nplt.figure(figsize=(7, 5))\nbars = plt.bar(attacks_per_year['year'], attacks_per_year['attack_count'], color='coral')\n\n#Anpassen der Achseneinteilung, die Nachkommastelle ist für eine bessere Darstellung der Balken\nplt.xlim(1999.5, 2022.5)\n\n# Hinzufügen von Beschriftungen und Titel\nplt.ylabel('Anzahl der Attacken')\nplt.xlabel('Jahre')\nplt.suptitle('Attacken pro Jahr in Deutschland', fontsize=20)\nplt.title('Angepasster Achsenbereich')\n\n# Anzeigen des Diagramms\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\nFigure 1: Anzahl der Attacken pro Jahr in Deutschland mit xlim()\n\n\n\n\n\nDas Beispiel in Figure 1 zeigt uns die Anzahl der Angriffe pro Jahr in Deutschland. Dabei haben wir die x-Achse mithilfe von plt.xlim() so angepasst, dass wir alle Attacken ab dem Jahr 2000 angezeigt bekommen.\n\n\n\nAbstände zwischen den Achsenstrichen\nAuch die Achseneinteilung wird von matplotlib automatisch gewählt, wir können diese aber genauso individualisieren. So können wir die Abstände zwischen den Strichen anpassen, zum Beispiel alle 2 Jahre:\n\n\nCode\nimport matplotlib.pyplot as plt\nimport pandas as pd\n\n#Einlesen des Datensatzes\ndf = pd.read_excel('2023-rtv-1990-2022_without-sources.xlsx')\n\n# Filtern der Daten für Deutschland\ndf_germany = df[df['country_name'] == 'Germany']\n\n# Zählen der Angriffe pro Jahr\nattacks_per_year = df_germany.groupby('year').size().reset_index(name='attack_count')\n\n# Erstellen des Balkendiagramms\nplt.figure(figsize=(7, 5))\nbars = plt.bar(attacks_per_year['year'], attacks_per_year['attack_count'], color='coral')\n\n#Anpassen der Achseneinteilung, die Nachkommastelle ist für eine bessere Darstellung der Balken\nplt.xlim(1999.5, 2022.5)\n\n#Anpassen der Skalenstriche (alle 2 Jahre)\nplt.xticks(range(2000, 2023, 2))\n\n# Hinzufügen von Beschriftungen und Titel\nplt.ylabel('Anzahl der Attacken')\nplt.xlabel('Jahre')\nplt.suptitle('Attacken pro Jahr in Deutschland', fontsize=20)\nplt.title('Striche alle 2 Jahre')\n\n# Anzeigen des Diagramms\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\nFigure 2: Anzahl der Attacken pro Jahr in Deutschland mit xticks()\n\n\n\n\n\n\nMit den Funktionen plt.xticks() und plt.yticks() kann die Position von Achsenstrichen angepasst werden. Als Argument brauchen diese Funktion jeweils ein Array oder eine Liste mit der gewünschten Position der Skaleneinteilung. Hier in Figure 2 haben wir der Funktion plt.xticks() das Argument range(2000, 2023, 2) übergeben, was bedeutet, dass alle 2 Jahre die Jahreszahl zwischen 2000 und 2023 als Strich erscheint.\n\n\n\nUnbeschriftete Achsenstriche\nWas auch sehr praktisch sein kann, sind zusätzliche unbeschriftete Striche zwischen zwei Haupt-Achsenstrichen. Diese können wir einfach durch plt.minorticks_on() hinzufügen. Diese Striche erscheinen dann sowohl auf der y- als auch auf der x-Achse:\n\n\nCode\nimport matplotlib.pyplot as plt\nimport pandas as pd\n\n#Einlesen des Datensatzes\ndf = pd.read_excel('2023-rtv-1990-2022_without-sources.xlsx')\n\n# Filtern der Daten für Deutschland\ndf_germany = df[df['country_name'] == 'Germany']\n\n# Zählen der Angriffe pro Jahr\nattacks_per_year = df_germany.groupby('year').size().reset_index(name='attack_count')\n\n# Erstellen des Balkendiagramms\nplt.figure(figsize=(7, 5))\nbars = plt.bar(attacks_per_year['year'], attacks_per_year['attack_count'], color='coral')\n\n#Anpassen der Achseneinteilung, die Nachkommastelle ist für eine bessere Darstellung der Balken\nplt.xlim(1999.5, 2022.5)\n\n#Anpassen der Skalenstriche (alle 2 Jahre)\nplt.xticks(range(2000, 2023, 2))\n\n#Hinzufügen von unbeschrifteten Strichen auf beiden Achsen\nplt.minorticks_on()\n\n#Setzen der unbeschrifteten Striche pro Balken auf der x-Achse\nplt.gca().xaxis.set_minor_locator(plt.MultipleLocator(1))\n\n# Hinzufügen von Beschriftungen und Titel\nplt.ylabel('Anzahl der Attacken')\nplt.xlabel('Jahre')\nplt.suptitle('Attacken pro Jahr in Deutschland', fontsize=20)\nplt.title('Mit unbeschrifteten Strichen')\n\n# Anzeigen des Diagramms\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\nFigure 3: Anzahl der Attacken pro Jahr in Deutschland mit minorticks_on()\n\n\n\n\n\nDamit die Striche auch pro Balken erscheinen und nicht irgendwo dazwischen, haben wir in Figure 3 noch die Zeile plt.gca().xaxis.set_minor_locator(plt.MultipleLocator(1)) zusätzlich zu plt.minorticks_on() hinzugefügt. Das sorgt dafür, dass die sogenannten “minor-ticks” pro Jahr zwischen den Hauptstrichen erscheinen.",
    "crumbs": [
      "Startseite",
      "Gestaltung",
      "Achsenanpassungen"
    ]
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "Über die Website",
    "section": "",
    "text": "Auf dieser Website wird in die Datenvisualisierung mit Python eingeführt. Die Einführung richtet sich an Studierende mit geringer bis keiner Vorerfahrung und ist speziell für Anwendungsfälle im geisteswissenschaftlichen Forschungskontext konzipiert.\nVorgestellt werden die Python Bibliotheken:\n\npandas zur Datenverarbeitung\nmatplotlib zur Visualisierung\n\nUm die vorgestellten Methoden zu verstehen, werden Grundkenntnisse in der Programmiersprache Python vorausgesetzt. Bei Python handelt es sich um eine höhere Programmiersprache, die jedoch als einsteigerfreundlich und leicht zu erlernen gilt. Für Python stehen zahlreiche online Tutorials zur Verfügung. Einen Einstieg bietet zum Beispiel die Lernplattform w3schools.\n\nEnstanden ist diese Website im Kontext des Seminars Erarbeitung Schulungsmaterialien, das, unter Leitung von Dr. Franziska Klemstein, im Sommersemester 2024 an der Johannes-Gutenberg-Universität Mainz stattfand."
  },
  {
    "objectID": "barChart.html",
    "href": "barChart.html",
    "title": "Bar Charts",
    "section": "",
    "text": "Bar Charts, oder auf deutsch Balkendiagramme, eignen sich besonders für den Vergleich von Kategorien oder Gruppen. Sie ermöglichen, die Größenordnungen verschiedener Kategorien schnell zu erfassen.\n\n\nGrundsätzliche Struktur eines Balkendiagramms\nDas folgende Beispiel zeigt die grundlegende Struktur eines einfachen Balkendiagramms:\n\n\nCode\n# importiere matplotlib \nimport matplotlib.pyplot as plt\n\n# Daten für das Balkendiagramm\ncategories = ['A', 'B', 'C']\nvalues = [10, 20, 15]\n\n# Erstelle Balkendiagramm \nplt.bar(categories, values)\n\n# Füge Labels und Titel hinzu\nplt.xlabel('Categories')\nplt.ylabel('Values')\nplt.title('Simple Bar Chart')\n\n# Zeige Plot\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\nBeispiel anhand des RTV-Datensatzes\nWir haben in diesem Beispiel die Frage gestellt, wie insgesamt die Verteilung von tödlichen und nicht tödlichen Fällen ist. Weil wir hier zwei nominale Kategorien haben (tödlich und nicht-tödlich), eignet sich für diese Darstellung ein Balkendiagramm gut.\n\n\nCode\nimport pandas as pd \nimport matplotlib.pyplot as plt\n\n# Dateipfad\nfile_path = '2023-rtv-1990-2022_without-sources.xlsx'\n\n# Lese Excel-Datei ein \ndf = pd.read_excel(file_path, engine='openpyxl')\n\n# Gruppiere Daten\nfatal_counts = df['fatal'].value_counts()\n\n#Erstelle Balkendiagramm\nplt.bar(fatal_counts.index.map({0: 'nicht tödlich', 1: 'tödlich'}), fatal_counts.values)\n\n# Füge Beschriftungen und Titel hinzu\nplt.xlabel('Fälle')\nplt.ylabel('Anzahl')\nplt.title('Vergleich von tödlichen und nicht tödlichen Fällen')\n\n# Zeige Diagramm\nplt.show()\n\n\n\n\n\n\n\n\n\nIm Beispiel wird deutlich, dass nur ein kleiner Teil der verzeichneten Fälle tödlich war. Diese Art der Visualisierung hilft dabei, schnell zu erfassen, wie häufig bestimmte Ereignisse im Vergleich zu anderen auftreten.",
    "crumbs": [
      "Startseite",
      "Wahl der Visualisierung",
      "Bar Charts"
    ]
  },
  {
    "objectID": "datensatz.html",
    "href": "datensatz.html",
    "title": "Über den Datensatz",
    "section": "",
    "text": "Um die Prinzipien der Datenvisualisierung anhand konkreter Beispiele zu erklären, werden wir in diesem Kurs mit einem Datensatz aus dem geisteswissenschaftlichen Forschungskontext arbeiten. Es handelt sich um den Right Wing Terrorism and Violence (RTV)-Datensatz, der unter einer CC BY Lizenz im Internet zur Verfügung steht und seit 2015 von der RTV Steering Group unter Leitung von Jacob A. Ravndal gepflegt wird. Er enthält umfassende statistische Daten zu rechter Gewalt in Westeuropa ab 1990. Enthalten sind unter anderem Daten zu Opferzahlen und Opfergruppen von Angriffen, aber auch geographische Angaben. Besonders hilfreich ist die gute Dokumentation des Datensatzes: im RTV Error Profile und RTV Codebook finden sich umfassende Informationen zur Erhebung der Daten und möglichen Biases. Damit bietet der Datensatz vielfältige Möglichkeiten zur Analyse, hält aber auch einige Herausforderungen bereit, die bei der Arbeit mit Daten immer wieder auftreten.\nQuelle: Ravndal, Jacob Aasland (2016) “Right-wing terrorism and violence in Western Europe: Introducing the RTV dataset”, Perspectives on Terrorism, 10(3): 2-15"
  },
  {
    "objectID": "einfuehrung.html",
    "href": "einfuehrung.html",
    "title": "Einführung",
    "section": "",
    "text": "Willkommen zu unserem Kurs “Daten sichtbar machen”, der in die spannende Welt der Datenvisualisierung einführt, insbesondere mit Python und der beliebten Bibliothek matplotlib. Gemeinsam wollen wir Schritt für Schritt anhand eines tatsächlichen Datensatzes die Grundprinzipien der Datenvisualisierung lernen und die Herausforderungen in den Blick nehmen, die bei der Arbeit mit geisteswissenschaftlichen Daten entstehen können. Hier gibt es mehr Infos zu dem Datensatz, den wir verwenden.\n\n\nVoraussetzungen\nDer Kurs richtet sich an Anfänger der Datenvisualisierung, einige Grundlagen und technischen Einrichtungen sollten aber mitgebracht (oder vor Beginn des Kurses erarbeitet) werden.\n\nGrundkenntnisse in Python\nEine Python-Entwicklungsumgebung, z.B. Jupyter Notebook\nInstallation der Bibliotheken pandas und matplotlib\n\nHilfreiche Links gibt es hier.\n\n\n\nWarum ist Datenvisualisierung wichtig?\nIn unserer heutigen datengetriebenen Welt ist Datenvisualisierung ein unverzichtbares Werkzeug, um komplexe Datenmengen verständlich und anschaulich darzustellen. Sie hilft dabei, Muster, Trends und Ausreißer in den Daten zu erkennen, und ermöglicht eine wirkungsvolle Kommunikation der Ergebnisse.\n\n\n\nAchtung vor schlechten Visualisierungen\nBeim Erstellen von Visualisierungen ist allerdings Vorsicht geboten: Schlechte Visualisierungen sind im harmlosen Fall einfach nur hässlich oder schwer leserlich, im schlimmsten Fall (absichtlich?) irreführend. Dem folgenden Beispiel gelingt sogar das Kunststück, diese Merkmale schlechter Visualisierungen zu vereinen. Es suggeriert - für Menschen mit Rot-Grün-Schwäche völlig unleserlich - eine überwältigende Mehrheit in der Frage, wie viele Menschen Visualisierungen lernen möchten:\n\n\n\nschlechtes Beispiel\n\n\nKeine Sorge, wir haben keine manipulativen Absichten mit diesem Diagramm, auch wenn wir natürlich hoffen, dass Sie Lust haben zu lernen, wie man gute Datenvisualisierungen erstellt.\n\n\n\nWas macht eine gute Visualisierung aus?\nEine gute Datenvisualisierung ist, anders als obiges Beispiel, sowohl faktisch korrekt als auch optisch ansprechend, und sollte eine eindeutige Aussage haben, die auf einen Blick verständlich ist. Doch wie erstellt man eine Visualisierung, die all diese Kriterien erfüllt? Das wollen wir in den folgenden Kapiteln in Angriff nehmen, um schrittweise vom Datensatz zur Visualisierung zu kommen und das erklärte Ziel zu erfüllen: Daten sichtbar machen!",
    "crumbs": [
      "Startseite",
      "Einführung"
    ]
  },
  {
    "objectID": "farben.html",
    "href": "farben.html",
    "title": "Farben",
    "section": "",
    "text": "Die Farbauswahl ist entscheidend für gelungene Datenvisualisierungen. Falsche Farbwahl kann eine gute Visualisierung zerstören. Farben sollten einen Zweck erfüllen, klar sein und nicht ablenken.\nDieser Abschnitt beschäftigt sich damit, wie man Farben anpassen kann und auf was man dabei achten sollte.\nIn matplotlib lassen sich Farben von Elementen allgemein über den Parameter color anpassen. Diesem Parameter können wir einen bestimmten Farbnamen als String übergeben wie z.B. \"blue\" oder \"pink\". Zudem haben wir aber auch die Möglichkeit Farbnummern oder RGB-Farbcodes zu benutzen. Möchten wir eine vorgefertigte Liste an Farben verwenden, eignen sich auch colormaps.\nWie und für was wir Farben verwenden, kann in einer Visualisierung sehr unterschiedlich sein, je nachdem, was man zeigen möchte. Farbe kann unter anderem verwendet werden um:\n\nDaten voneinander zu unterscheiden\nDatenwerte zu repräsentieren\nInformationen hervorzuheben\n\n\n\nDaten voneinander unterscheiden\nFarben können uns dabei helfen, verschiedene Dinge zu unterscheiden, die keine besondere Reihenfolge haben, um so qualitative Unterschiede hervorzuheben. Dafür verwenden wir sogenannte qualitative Farbskalen, da diese verschiedene eindeutig unterscheidbare Farben verwenden.\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport pandas as pd\n\n# Datensatz einlesen\ndf = pd.read_excel('2023-rtv-1990-2022_without-sources.xlsx')\n\n# Gruppieren der Daten nach Land und Waffenart und Zählen der Angriffe\ngrouped_data = df.groupby(['country_name', 'grouped_weapon_type']).size().unstack(fill_value=0)\n\n# Sortieren der Länder nach der Gesamtzahl der Angriffe\ntotal_attacks_per_country = grouped_data.sum(axis=1).sort_values(ascending=False)\ngrouped_data = grouped_data.loc[total_attacks_per_country.index]\n\n# Benutzerdefinierte Liste von Farben\ncolors = ['cornflowerblue', 'lightpink', 'mediumseagreen', 'gold', 'mediumpurple', 'sandybrown']\n\n# Erstellen des gestapelten Balkendiagramms\nfig, ax = plt.subplots(figsize=(7.5, 8))\n\n# Erstellen der Balken für jede Zielgruppe\ntarget_groups = grouped_data.columns\nbottom = np.zeros(len(grouped_data))\nfor target_group, color in zip(target_groups, colors):\n    values = grouped_data[target_group].values\n    ax.barh(grouped_data.index, values, label=target_group, color=color, left=bottom)\n    bottom += values\n\n# Hinzufügen von Beschriftungen und Titel\nax.set_xlabel('Anzahl der Attacken')\nax.set_title('Attacken pro Waffenart und Land', fontsize=20)\nax.legend(title='Waffenarten', loc=\"upper right\", fontsize=10)\n\n# Anzeigen des Diagramms\nplt.tight_layout()\nplt.show()\n\n\n\n\n\nAnzahl der Attacken pro Waffenart und Land\n\n\n\n\nDie hier erstellte Visualisierung zeigt die Anzahl der Angriffe pro Waffenart und Land in einem gestapelten Balkendiagramm.\nDie Daten wurden hierfür nach Waffenart und Land gruppiert, anschließend wurden die Anzahl der Angriffe gezählt und als Balken dargestellt, bei denen die einzelnen Abschnitte die verschiedenen Waffenarten repräsentieren.\nEine qualitative Farbskala eignet sich hier perfekt, um die jeweiligen Waffenarten unterscheiden zu können. Dabei bekommt jede Waffenart eine eigene Farbe aus unserer benutzerdefinierten Liste colors = ['cornflowerblue', 'lightpink', 'mediumseagreen', 'gold', 'mediumpurple', 'sandybrown']. In der for-Schleife for target_group, color in zip(weapons, colors) werden unsere Farben dann mit einer Waffenart kombiniert, wobei jede Iteration ein neues Paar erzeugt, für welches dann der Balken erstellt wird.\nIn diesem Fall helfen Farben dabei verschiedene Kategorien in einem Diagramm visuell zu unterscheiden, damit einfach erkannt werden kann, um welche Daten es sich handelt.\n\n\n\nRepräsentation von Datenwerten\nFarben können auch nützlich sein, um Datenwerte darzustellen, wie etwa Einkommen, Temperatur oder auch Anzahlen.\nDafür verwenden wir eine sequenzielle Farbskala. Diese Skala zeigt eine Reihe von Farben, die klar machen, welche Werte größer oder kleiner sind und wie weit zwei bestimmte Werte voneinander entfernt sind. Eine solche Farbskala muss also gleichmäßig über den gesamten Bereich variieren.\nSequenzielle Skalen können auf einer einzelnen Farbe basieren (z.B. von dunkelblau zu hellblau) oder auch auf mehreren Farben (z.B. von dunkelrot zu hellgelb). Dabei ist ein sinnvoller Farbübergang wichtig. So sieht eine Skala von Dunkelgelb zu Hellblau unnatürlich aus und bildet keine nützliche sequenzielle Skala.\nBei unserem RTV-Datensatz eignet sich eine sequenzielle Farbskala, um z.B. die Fallzahlen pro Jahr und pro Land zu zeigen. Dafür erstellen wir eine Heatmap, wobei die Farbe von hell (wenige Fälle) zu dunkel (viele Fälle) variiert.\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport pandas as pd\n\n#Der Datensatz\ndf = pd.read_excel('2023-rtv-1990-2022_without-sources.xlsx')\n\n# Gruppieren nach Jahr und Land und Zählen der Angriffe\nattacks_per_year_country = df.groupby(['year', 'country_name']).size().unstack(fill_value=0)\n\n# Konvertierung in ein NumPy-Array für die Heatmap\nyears = attacks_per_year_country.index.values\ncountries = attacks_per_year_country.columns.values\ndata = attacks_per_year_country.values\n\n# Erstellen der Heatmap\nplt.figure(figsize=(9, 6))\nplt.imshow(data, cmap=\"PuRd\", aspect='auto')\nplt.colorbar(label='Anzahl der Attacken')\n\n# Setzen der Achsen-Ticks und Achsen-Beschriftungen\nplt.xticks(np.arange(len(countries)), countries, rotation=55)\nplt.yticks(np.arange(len(years)), years)\n\n# Hinzufügen von Beschriftungen und Titel\nplt.title('Anzahl der Attacken pro Land und Jahr', fontsize=20)\n\n# Enge Anordnung und Anzeige der Heatmap\nplt.tight_layout()\nplt.show()\n\n\n\n\n\nAnzahl der Attacken pro Land und Jahr\n\n\n\n\nDie von uns erstellte Heatmap verwendet die Funktion plt.imshow(data, cmap=\"PuRd\", aspect='auto'). Dem Parameter cmap, kann der Name der Colormap als String einfach zugewiesen werden. Die hier verwendete Colormap ist eine sequenzielle Farbskala, welche numerische Werte in Farben übersetzt. Der helle Farbton entspricht hier also niedrigen Werten und Dunkelrot hohen Werten. Hier werden die weiteren Parameter der Funktion plt.imshow()ausführlich beschrieben. ___ ### Hervorheben von Informationen\nFarben sind super, um bestimmte Dinge in unseren Daten hervorzuheben. Wenn es Kategorien oder Werte gibt, die besonders wichtig sind, können wir diese mit auffälligen Farben hervorheben. Eine gute Methode ist die Verwendung von Akzentfarbskalen, die sowohl sanfte als auch kräftigere Farben enthalten.\nBeim Einsatz von Akzentfarben sollten wir darauf achten, dass die Grundfarben nicht zu sehr um Aufmerksamkeit kämpfen. Ein häufiger Fehler ist, dass die Grundfarben zu bunt sind und mit den Akzentfarben konkurrieren. Eine einfache Lösung ist es, alle anderen Farben in der Grafik zu entfernen und nur die wichtigen Datenpunkte farblich hervorzuheben.\n\n\nCode\nimport matplotlib.pyplot as plt\nimport pandas as pd\n\n#Der Datensatz\ndf = pd.read_excel('2023-rtv-1990-2022_without-sources.xlsx')\n\n# Filtern der Daten für Deutschland\ndf_germany = df[df['country_name'] == 'Germany']\n\n# Zählen der Angriffe pro Jahr\nattacks_per_year = df_germany.groupby('year').size().reset_index(name='attack_count')\n\n# Definieren der Farben\ndefault_color = 'wheat'\nhighlight_color = 'goldenrod'\nhighlight_year = 2016\n\n# Erstellen des Balkendiagramms\nplt.figure(figsize=(7, 6))\nbars = plt.bar(attacks_per_year['year'], attacks_per_year['attack_count'],\n               color=[highlight_color if year == highlight_year else default_color for year in attacks_per_year['year']])\n\n# Hinzufügen von Beschriftungen und Titel\nplt.ylabel('Anzahl der Attacken')\nplt.title('Anzahl der Angriffe pro Jahr in Deutschland', fontsize=20)\n\n# Anzeigen des Diagramms\nplt.tight_layout()\nplt.show()\n\n\n\n\n\nAnzahl der Attacken pro Jahr in Deutschland\n\n\n\n\nSo können Akzentfarben etwa verwendet werden, um ein bestimmtes Jahr in der Anzahl der Angriffe pro Jahr in Deutschland hervorzuheben. Das von uns erstellte Balkendiagramm zeigt die Anzahl der Angriffe pro Jahr für Deutschland, wobei alle Balken die gleiche Farbe haben und der Balken für das Jahr 2016 farblich hervorgehoben wird, um zu zeigen, dass es in diesem Jahr besonders viele Angriffe gab.\nMithilfe von default_color = 'wheat' wird die normale Balkenfarbe festgelegt und mit highlight_color = 'goldenrod' die Akzentfarbe. highlight_year legt dann das Jahr fest, das hervorgehoben werden soll.\nDie Farben der Balken werden mithilfe einer List Comprehension definiert color=[highlight_color if year == highlight_year else default_color for year in attacks_per_year['year']] Hier wird highlight_color nur für den Balken 2016 verwendet, während alle anderen Balken die default_color bekommen.\nEine Liste der Farbnamen in Matplotlib kann hier gefunden werden.\n\n\n\nHäufige Fehler\n\n\nZu viele Farben\nWenn wir in einem Diagramm zu viele Farben einsetzen oder Farben ohne klaren Zweck verwenden, kann das schnell unübersichtlich werden. Wenn wir mehr als etwa acht Kategorien unterscheiden müssen, ist es besser eine übersichtlichere Darstellung zu wählen, anstatt sich auf Farben zu verlassen.\n\n\nCode\nimport matplotlib.pyplot as plt\nimport pandas as pd\nimport numpy as np \n\n#Einlesen des Datensatzes\ndf = pd.read_excel('2023-rtv-1990-2022_without-sources.xlsx')\n\n# Zählen der Attacken pro Land und pro Jahr\nattacks_per_year_per_country = df.groupby(['year', 'country_name']).size().unstack(fill_value=0)\n\n# Farbzuweisung der Länder\nnum_countries = len(attacks_per_year_country.columns)\ncolors = plt.cm.turbo(np.linspace(0, 1, num_countries)) # Hier wird die colormap turbo verwendet \n\n# Erstellen des Diagramms\nfig, ax = plt.subplots(figsize=(7.5, 6))\nattacks_per_year_country.plot(kind='bar', stacked=True, ax=ax, color = colors)\n\n# Beschriften und hinzufügen der Legende\nax.set_xlabel('Jahr')\nax.set_ylabel('Anzahl der Attacken')\nax.set_title('Anzahl der Attacken pro Land und Jahr', fontsize=15)\nax.legend(title='Land', loc=\"upper left\", fontsize=8)\n\n# Anzeigen \nplt.show()\n\n\n\n\n\nAnzahl der Attacken pro Land und Jahr als Negativ-Beispiel für zu viele Farben\n\n\n\n\nIn dieser Visualiserung, die uns die Anzahl der Attacken pro Land und Jahr zeigen soll, gibt es leider viel zu viele Länder, zwischen denen farblich unterschieden werden muss, weshalb wir lieber eine andere Art der Darstellung wählen sollten. Hier würde sich zum Beispiel eine Heatmap wie im Beispiel oben besser eignen.\n\n\nDie Verwendung nicht-monotoner Farbskalen\nDie bekannte Regenbogenfarbskala ist leider nicht ideal, um Datenwerte darzustellen. Sie ist zirkulär und nicht-monoton, was bedeutet, dass die Farben nicht gleichmäßig den Datenwerten entsprechen. In Graustufen sieht man, dass diese Skala große Helligkeitsunterschiede aufweist.\n\n\n\nRegenbogenfarbskala in Graustufen\n\n\nDies kann dazu führen, dass wichtige Datenmerkmale verschleiert oder unnötig betont werden. Stattdessen ist es besser Farbskalen zu wählen, die gleichmäßig und klar sind, damit unsere Daten richtig und verständlich dargestellt werden. Dafür eignen sich colormaps wie \"viridis\", \"plasma\", \"inferno\", \"magma\" oder \"cividis\".\n\n\nNicht für Farbsehschwächen gestalten\nWenn wir Farben für Diagramme auswählen, sollten wir darauf achten, dass sie auch von Menschen mit Farbsehschwächen gut erkannt werden. Etwa 8% der Männer und 0,5% der Frauen haben eine Form von Farbsehschwäche. Während sequentielle Farbskalen in der Regel gut funktionieren, müssen wir bei qualitativen Skalen besonders darauf achten und sicherstellen, dass unsere Farben für alle gut erkennbar sind. Dabei sollten insbesondere Rot-Grün Kombinationen vermieden werden, stattdessen eignen sich Farben wie Blau und Gelb sehr gut. Auch das Verwenden von Hochkontrastfarben sorgt für eine gute Erkennbarkeit. Geeignete qualitative colormaps wären zum Beispiel \"tab10\", \"Set1\", \"Dark2\", \"Paired\" oder \"Accent\".\nAuch kann die Verwendung von Mustern und Texturen dabei helfen Informationen leichter unterscheidbar zu machen, wie etwa durch verschiedene Formen oder Linienstile.\nZudem kann diese Webseite benutzt werden, um zu testen wie unsere Diagrmme von Menschen mit verschiedenen Arten von Farbsehschwäche wahrgenommen werden.",
    "crumbs": [
      "Startseite",
      "Gestaltung",
      "Farben"
    ]
  },
  {
    "objectID": "Gestaltung.html",
    "href": "Gestaltung.html",
    "title": "Gestaltung",
    "section": "",
    "text": "Die Gestaltung einer Visualisierung richtet sich nach der Art der Daten. Eine gute Visualisierung sollte dabei die Daten klar und genau darstellen, ohne irreführend zu sein oder die Daten zu verzerren. Gleichzeitig sollte sie auch optisch ansprechend sein, da eine ansprechende Darstellung die Aussagekraft der Visualisierung verstärken kann. Ablenkende Farben, unausgewogene Gestaltungselemente oder andere störende Merkmale machen es dem Betrachter schwerer, die Informationen richtig zu interpretieren.\nEs gibt mehrere Punkte, die bei der Gestaltung beachtet werden sollten, an denen sich dieses Kapitel orientiert:\n\nAchsenanpassungen: Wie können Achsen angepasst werden?\nFormen und Linien: Wie können Formen und Linien verwendet und angepasst werden?\nFarben: Wie können wir Farben verwenden?\nBeschriftungen: Wie gestalten wir Text?\nÜberlappungen vermeiden: Wie können wir mit Überlappungen von Datenpunkten umgehen?",
    "crumbs": [
      "Startseite",
      "Gestaltung"
    ]
  },
  {
    "objectID": "histogramm.html",
    "href": "histogramm.html",
    "title": "Histogramme",
    "section": "",
    "text": "Bei einem Histogramm handelt es sich um die grafische Darstellung einer Häufigkeitsverteilung in Form von Säulen, die den Häufigkeiten der Messwerte entsprechen. Von Balkendiagrammen unterscheiden sie sich vor allem in der Art der Daten: Sie kommen bei stetigen, numerischen Daten zum Einsatz, Balkendiagramme hingegen bei kategorialen oder nominalen Daten. Histogramme eignen sich damit besonders für die Darstellung von Häufigkeitsverteilungen, bei denen die Verteilung einer stetigen Variable untersucht werden soll. Für statistische Anwendungen sind sie sehr nützlich, weil sie helfen können, die Mitte und Streuung eines Datensatzes zu erkennen.\n\nGrundsätzliche Struktur eines Histogramms\nHier ist ein einfaches Beispiel für ein Histogramm, das die Verteilung einer Liste von Zahlen zeigt:\n\n\nCode\nimport matplotlib.pyplot as plt\n\n# Beispiel-Daten: Eine kleine Liste von Zahlen\ndata = [1, 2, 2, 3, 3, 3, 4, 4, 4, 4, 5, 5, 6]\n\n# Erstellen des Histogramms\nplt.figure(figsize=(8, 5))\nplt.hist(data, bins=6, edgecolor='black')\n\n# Hinzufügen von Beschriftungen und Titel\nplt.xlabel('Wert')\nplt.ylabel('Häufigkeit')\nplt.title('Einfaches Histogramm-Beispiel')\n\n# Anzeigen des Diagramms\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\nBeispiel anhand des RTV-Datensatzes\nIn diesem Beispiel analysieren wir die Verteilung der Anzahl der getöteten Personen bei Angriffen im Laufe der Jahre. Diese Art der Analyse kann helfen, Trends oder Muster im Zeitverlauf zu erkennen.\n\n\nCode\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Dateipfad\nfile_path = '2023-rtv-1990-2022_without-sources.xlsx'\n\n# Lese Excel-Datei ein\ndf = pd.read_excel(file_path, engine='openpyxl')\n\n# Filtern der Daten für tödliche Fälle (n_killed &gt; 0)\ndf_fatal = df[df['n_killed'] &gt; 0]\n\n# Aggregieren der Daten: Summe der 'n_killed' pro Jahr\nyearly_killed = df_fatal.groupby('year')['n_killed'].sum()\n\n# Erstellen des Histogramms für die Summe der 'n_killed' pro Jahr\nplt.bar(yearly_killed.index, yearly_killed.values, edgecolor='black')\n\n# Hinzufügen von Beschriftungen und Titel\nplt.xlabel('Jahr')\nplt.ylabel('Anzahl der getöteten Personen')\nplt.title('Verteilung der getöteten Personen nach Jahr')\n\n# Anzeigen des Diagramms\nplt.show()",
    "crumbs": [
      "Startseite",
      "Wahl der Visualisierung",
      "Histogramme"
    ]
  },
  {
    "objectID": "kapitel2.html",
    "href": "kapitel2.html",
    "title": "Fragen an Datensatz formulieren",
    "section": "",
    "text": "Wir haben den Datensatz ausgewählt und erfolgreich eingelesen. Aber wie geht es weiter? Man steht vor einem großen Datenberg und fragt sich nun wahrscheinlich: Was genau will man eigentlich visualisieren? Und welche Schritte sind nötig, um dorthin zu gelangen? Bevor man überhaupt beginnt, aus einem Datensatz Visualisierungen zu erstellen, ist es essentiell, die richtigen Fragen an den Datensatz zu stellen. Dies ähnelt ein wenig dem Prozess der Themenfindung für eine Hausarbeit: auch hier überlegt man sich besser das Thema, bevor man mit dem Schreiben beginnt, auch wenn sich natürlich im Prozess weitere Ideen ergeben können. Um gezielt Informationen herauszufiltern und darzustellen, sollte man also wissen, welche Fragen man an die Daten hat. Hierfür ist es nötig, dass man den Datensatz schon ein Stück weit kennt, indem man sich zum Beispiel mit pandas die Spaltenüberschriften und ersten Einträge angeschaut hat [hier verlinken zu entsprechendem Kapitel]. Darauf aufbauend kann man sich dann solche Fragen stellen wie: Für welche Spalte(n) interessiere ich mich? Welche Beziehungen zwischen Variablen möchte ich untersuchen?\nDas ist jetzt alles noch etwas unkonkret, daher ein paar Beispiele in Bezug auf unseren Datensatz zu rechter Gewalt: Man könnte sich etwa fragen, in welchem Land es besonders viele Fälle gibt, oder welche Entwicklungen im Laufe der Zeit zu identifizieren sind… [später hier ausbauen/konkretisieren]"
  },
  {
    "objectID": "linePlot.html",
    "href": "linePlot.html",
    "title": "Line Charts",
    "section": "",
    "text": "Line Charts beziehungsweise Liniendiagramme sind besonders für die Darstellung von Datenpunkten über einen kontinuierlichen Zeitraum geeignet. In ihnen wird in der Regel der Zusammenhang zweier Merkmale dargestellt. Möglich sind hier auch Multiple Line Charts, bei denen mehrere Datenreihen gleichzeitig angezeigt werden, wobei Trends über die Zeit verglichen werden können.\n\nGrundsätzliche Struktur eines Liniendiagramms\nIm folgenden Beispiel erstellen wir ein einfaches Liniendiagramm, um eine Reihe von Werten über verschiedene Zeitpunkte darzustellen:\n\n\nCode\nimport matplotlib.pyplot as plt\n\n# Beispiel-Daten\nx = [1, 2, 3, 4, 5]  # Zeitpunkte (z.B. Tage)\ny = [2, 3, 5, 7, 11]  # Werte (z.B. Messungen oder Werte an diesen Zeitpunkten)\n\n# Erstellen des Liniendiagramms\nplt.plot(x, y)\n\n# Hinzufügen von Beschriftungen und Titel\nplt.xlabel('Zeitpunkte')\nplt.ylabel('Werte')\nplt.title('Einfaches Liniendiagramm')\n\n# Anzeigen des Diagramms\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\nBeispiel anhand des RTV-Datensatzes\nIn diesem Beispiel analysieren wir die Entwicklung tödlicher Fälle in Deutschland. Dabei verwenden wir den RTV-Datensatz, um die Anzahl der Fälle über die Jahre darzustellen.\n\n\nCode\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Dateipfad\nfile_path = '2023-rtv-1990-2022_without-sources.xlsx'\n\n# Lese Excel-Datei ein \ndf = pd.read_excel(file_path, engine='openpyxl')\n\n# Filter für \"Germany\", nur tödliche Fälle\ndf_germany = df[(df['country_name'] == 'Germany') & (df['fatal'] == 1)]\n\n# Häufigkeit der Jahre zählen\nyear_counts_germany = df_germany['year'].value_counts().sort_index()\n\n# Liniendiagramm erstellen\nplt.plot(year_counts_germany.index, year_counts_germany.values, label='Germany')\n\n# Hinzufügen von Beschriftungen und Titel\nplt.xlabel('Jahr')\nplt.ylabel('Wert')\nplt.title('Verteilung der tödlichen Fälle nach Jahr (Deutschland)')\n\n# Anzeigen des Diagramms\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\nMultiple Line Charts\nUm mehrere Datensätze gleichzeitig zu vergleichen, verwenden wir Multiple Line Charts. Dies hilft, Unterschiede und Ähnlichkeiten in den Trends zwischen verschiedenen Gruppen oder Kategorien sichtbar zu machen. Hier vergleichen wir die Entwicklung der Fälle rechter Gewalt zwischen Italien, Deutschland und Frankreich ab 2015:\n\n\nCode\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Dateipfad\nfile_path = '2023-rtv-1990-2022_without-sources.xlsx'\n\n# Lese Excel-Datei ein \ndf = pd.read_excel(file_path, engine='openpyxl')\n\n# Filter für Deutschland, Italien und Frankreich ab dem Jahr 2015\ndf_filtered = df[(df['country_name'].isin(['Germany', 'Italy', 'France'])) & (df['year'] &gt;= 2015)]\n\n# Filter für jedes Land separat\ndf_germany = df_filtered[df_filtered['country_name'] == 'Germany']\ndf_italy = df_filtered[df_filtered['country_name'] == 'Italy']\ndf_france = df_filtered[df_filtered['country_name'] == 'France']\n\n# Häufigkeit der Jahre zählen\nyear_counts_germany = df_germany['year'].value_counts().sort_index()\nyear_counts_italy = df_italy['year'].value_counts().sort_index()\nyear_counts_france = df_france['year'].value_counts().sort_index()\n\n# Liniendiagramm erstellen \nplt.plot(year_counts_germany.index, year_counts_germany.values, color='blue', label='Germany')\nplt.plot(year_counts_italy.index, year_counts_italy.values, color='orange', label='Italy')\nplt.plot(year_counts_france.index, year_counts_france.values, color='red', label='France')\n\n# Hinzufügen von Beschriftungen und Titel\nplt.xlabel('Jahr')\nplt.ylabel('Häufigkeit')\nplt.title('Verteilung der Fälle ab 2015: Deutschland, Italien und Frankreich')\nplt.legend()  # Fügt eine Legende hinzu\n\n# Anzeigen des Diagramms\nplt.show()",
    "crumbs": [
      "Startseite",
      "Wahl der Visualisierung",
      "Line Charts"
    ]
  },
  {
    "objectID": "pandas.html",
    "href": "pandas.html",
    "title": "Datensatz bereinigen",
    "section": "",
    "text": "Jede Datenbereinigung stellt letztlich einen Eingriff in die Daten und damit eine Manipulation derselben dar. Datenbereinigung ist dennoch in den meisten Fällen unerlässlich, zum Beispiel, wenn Datensätze Inkonsistenzen und Unvollständigkeiten aufweisen. Wir nennen sie dann dirty data. In den folgenden Abschnitten werden wir lernen, dirty data in nutzbare Daten zu verwandeln. Dabei ist jedoch der Umgang mit Leerstellen oder Formatierungsfehlern weniger problematisch als der Umgang mit Ungereimtheiten in den Daten. Hier ist es besonders wichtig, die einzelnen Schritte unserer Datenbereinigung zu reflektieren und zu dokumentieren um sie dadurch für nachnutzende Forschung transparent zu halten.\n\n\nAusreißer\nUngereimtheiten in den Daten können zum Beispiel sogenannte Ausreißer sein. Das sind Extremwerte innerhalb der Daten. Mitunter resultieren sie aus Messfehlern, ungleicher Datenerfassung oder Formatierungsfehlern. In unserem Beispiel gibt es auch einen Extremwert. Doch es handelt sich nicht um einen Fehler. Die Zahl von über 200 Opfern bei einer einzigen Attacke, die sich in Norwegen im Jahr 2011 ereignete, geht auf den rechtsextremen Anschlag auf der Insel Utoya zurück. Hier müssen wir also entscheiden, ob wir diesen Wert in unsere Berechnungen einbeziehen, oder ob wir ihn (begründet) aussortieren.\n\n# pandas laden und Datensatz einlesen\nimport pandas as pd\ndf = pd.read_excel('2023-rtv-1990-2022_without-sources.xlsx')\n\n\n# den Index des Extremwerts ermitteln:\n# alle nicht-numerischen Werte werden mit dem Wert '0' ersetzt.\ndf['n_wounded'] = pd.to_numeric(df['n_wounded'], errors='coerce').fillna(0).astype(int)\n# den Datensatz sortieren\ndf.sort_values(by='n_wounded', ascending=False).head(2)\n\n\n\n\n\n\n\n\n\ncase_id\nyear\nmonth\nday\ncountry_id\niso3\ncountry_name\nregion\ncity/village\nlocation\n...\nweapon_type_2\ngrouped_weapon_type_2\nweapon_description\nfatal\nn_killed\nn_wounded\ndescription\nplot_type\nplot_targeting\nplot_operational_planning\n\n\n\n\n484\n2011-7-22\n2011\n7\n22\n13\nNOR\nNorway\nOslo\nOslo/Utøya\nOslo, regjeringskvartalet; Utøya\n...\n300.0\nFirearms\nFertilizer bomb, Ruger Mini 14 (semi-automatic...\n1\n77\n262\nThe 2011 Norway attacks, referred to in Norway...\nNaN\nNaN\nNaN\n\n\n70\n1992-8-24\n1992\n8\n24\n6\nDEU\nGermany\nMecklenburg-Vorpommern\nRostock\nLichtenhagen\n...\nNaN\nNaN\nUnknown\n0\n0\n117\nFrom August 22 to August 24, violent xenophobi...\nNaN\nNaN\nNaN\n\n\n\n\n2 rows × 34 columns\n\n\n\n\n Mit idxmax() können wir sehr leicht den Index des höchsten Wertes einer Spalte zurückgeben lassen und die entsprechende Zeile anschließend löschen.\n\nmax_row_index = df['n_wounded'].idxmax()\ndf_dropped_max = df.drop(max_row_index)\ndf_dropped_max.sort_values(by='n_wounded', ascending=False).head(2)\n\n\n\n\n\n\n\n\n\ncase_id\nyear\nmonth\nday\ncountry_id\niso3\ncountry_name\nregion\ncity/village\nlocation\n...\nweapon_type_2\ngrouped_weapon_type_2\nweapon_description\nfatal\nn_killed\nn_wounded\ndescription\nplot_type\nplot_targeting\nplot_operational_planning\n\n\n\n\n70\n1992-8-24\n1992\n8\n24\n6\nDEU\nGermany\nMecklenburg-Vorpommern\nRostock\nLichtenhagen\n...\nNaN\nNaN\nUnknown\n0\n0\n117\nFrom August 22 to August 24, violent xenophobi...\nNaN\nNaN\nNaN\n\n\n210\n1999-4-30\n1999\n4\n30\n18\nGBR\nUnited Kingdom\nEngland\nLondon\nThe Admiral Duncan pub\n...\nNaN\nNaN\nNail bomb\n1\n3\n79\nThe Admiral Dunchan bomb was the third and fin...\nNaN\nNaN\nNaN\n\n\n\n\n2 rows × 34 columns\n\n\n\n\n\n\n\nInkonsistenzen\nFür Inkonsistenzen in einem Datensatz kann es vielfältige Gründe geben. Datensätze werden oft über Jahre oder Jahrzehnte hinweg gepflegt, während dieser Zeit kann sich die Art der Datenerfassung mehrfach ändern. Aber auch Formatierungsfehler oder Tippfehler können zu inkonsistenten Daten führen. Wenn wir Inkonsistenzen bereinigen, müssen wir uns für eine Darstellungsart entscheiden (zum Beispiel für ein Maßsystem) und den Rest der Daten entsprechend anpassen, unsere Entscheidungen sollten wir nachvollziehbar dokumentieren.\nMit der Funktion unique() können wir uns die unterschiedlichen Werte einer Spalte anzeigen lassen.\n\nunique_values = df['fatal'].unique()\nprint(unique_values)\n\n[0 1]\n\n\n\n\n\nNaN Werte\nUm NaN-Werte, also Leerstellen im Datensatz, zu finden können wir die Funktion isnull() nutzen. Zum Löschen vom Spalten und/ oder Zeilen steht die Funktion drop() zur Verfügung. dropna() ermöglicht zudem das Löschen der kompletten Zeile, die NaN-Werte enthält.\n\ndf.isnull()\n# sum() gibt die Summe aller NaN-Werte aus.\ndf.isnull().sum()\n\nnot_all_NaN_df = df.dropna(how='all') # löscht nur Zeilen in denen alle Werte NaN sind\nnot_any_NaN_df = df.dropna(how='any') # löscht auch Zeilen, in denen nur ein Wert NaN ist\n# mit info() erhalten wir eine Übersicht über NaN und nicht NaN Werte \nnot_any_NaN_df.info(5) \n\n&lt;class 'pandas.core.frame.DataFrame'&gt;\nIndex: 0 entries\nData columns (total 34 columns):\n #   Column                        Non-Null Count  Dtype  \n---  ------                        --------------  -----  \n 0   case_id                       0 non-null      object \n 1   year                          0 non-null      int64  \n 2   month                         0 non-null      object \n 3   day                           0 non-null      object \n 4   country_id                    0 non-null      int64  \n 5   iso3                          0 non-null      object \n 6   country_name                  0 non-null      object \n 7   region                        0 non-null      object \n 8   city/village                  0 non-null      object \n 9   location                      0 non-null      object \n 10  location_latitude             0 non-null      object \n 11  location_longitude            0 non-null      object \n 12  location_accuracy             0 non-null      object \n 13  incident_type                 0 non-null      int64  \n 14  perpetrator_type              0 non-null      int64  \n 15  organizational_affiliation    0 non-null      object \n 16  organizational_affiliation_2  0 non-null      object \n 17  loneactor_id                  0 non-null      float64\n 18  target_group                  0 non-null      int64  \n 19  grouped_target_group          0 non-null      object \n 20  target_group_2                0 non-null      float64\n 21  grouped_target_group_2        0 non-null      object \n 22  weapon_type                   0 non-null      int64  \n 23  grouped_weapon_type           0 non-null      object \n 24  weapon_type_2                 0 non-null      float64\n 25  grouped_weapon_type_2         0 non-null      object \n 26  weapon_description            0 non-null      object \n 27  fatal                         0 non-null      int64  \n 28  n_killed                      0 non-null      int64  \n 29  n_wounded                     0 non-null      int32  \n 30  description                   0 non-null      object \n 31  plot_type                     0 non-null      float64\n 32  plot_targeting                0 non-null      float64\n 33  plot_operational_planning     0 non-null      float64\ndtypes: float64(6), int32(1), int64(8), object(19)\nmemory usage: 0.0+ bytes\n\n\n Wenn wir die Zeilen mit NaN-Werten behalten möchten, können wir mit der Funktion fillna() alle gefundenen NaN-Werte durch einen beliebigen Wert ersetzen lassen, zum Beispiel auch mit dem berechneten Mittelwert.\n\n# für die Übersichtlichkeit wird zunächst ein dictionary erstellt\nvalues = {\"year\": df[\"year\"].mean(), \n          \"n_killed\": df[\"n_killed\"].mean()} \n# das dictionary wird als Parameter übergeben\nfilled_df = df.fillna(value=values) \nfilled_df.info()\n\n&lt;class 'pandas.core.frame.DataFrame'&gt;\nRangeIndex: 2001 entries, 0 to 2000\nData columns (total 34 columns):\n #   Column                        Non-Null Count  Dtype  \n---  ------                        --------------  -----  \n 0   case_id                       2001 non-null   object \n 1   year                          2001 non-null   int64  \n 2   month                         2001 non-null   object \n 3   day                           2001 non-null   object \n 4   country_id                    2001 non-null   int64  \n 5   iso3                          2001 non-null   object \n 6   country_name                  2001 non-null   object \n 7   region                        1795 non-null   object \n 8   city/village                  2001 non-null   object \n 9   location                      1744 non-null   object \n 10  location_latitude             1604 non-null   object \n 11  location_longitude            1604 non-null   object \n 12  location_accuracy             1601 non-null   object \n 13  incident_type                 2001 non-null   int64  \n 14  perpetrator_type              2001 non-null   int64  \n 15  organizational_affiliation    558 non-null    object \n 16  organizational_affiliation_2  76 non-null     object \n 17  loneactor_id                  558 non-null    float64\n 18  target_group                  2001 non-null   int64  \n 19  grouped_target_group          2001 non-null   object \n 20  target_group_2                203 non-null    float64\n 21  grouped_target_group_2        203 non-null    object \n 22  weapon_type                   2001 non-null   int64  \n 23  grouped_weapon_type           2001 non-null   object \n 24  weapon_type_2                 546 non-null    float64\n 25  grouped_weapon_type_2         546 non-null    object \n 26  weapon_description            2001 non-null   object \n 27  fatal                         2001 non-null   int64  \n 28  n_killed                      2001 non-null   int64  \n 29  n_wounded                     2001 non-null   int32  \n 30  description                   2001 non-null   object \n 31  plot_type                     114 non-null    float64\n 32  plot_targeting                114 non-null    float64\n 33  plot_operational_planning     114 non-null    float64\ndtypes: float64(6), int32(1), int64(8), object(19)\nmemory usage: 523.8+ KB\n\n\n\n\n\nWerte austauschen\nMit Hilfe der Funktion replace() können wir Werte in unserem DataFrame austauschen.\n\n# hier erstellen wir eine Kopie unseres Dataframe um das Original später noch verwenden zu können\nreplaced_df = df\nreplaced_df['case_id']=df['case_id'].str.replace('-','.', regex=False) \n# der erste Parameter wird durch den zweiten ersetzt\nreplaced_df.head()\n\n\n\n\n\n\n\n\n\ncase_id\nyear\nmonth\nday\ncountry_id\niso3\ncountry_name\nregion\ncity/village\nlocation\n...\nweapon_type_2\ngrouped_weapon_type_2\nweapon_description\nfatal\nn_killed\nn_wounded\ndescription\nplot_type\nplot_targeting\nplot_operational_planning\n\n\n\n\n0\n1990.3.4\n1990\n3\n4\n13\nNOR\nNorway\nOslo\nOslo\nNaN\n...\nNaN\nNaN\nCS-gas\n0\n0\n0\nUnknown perpetrators threw a military grenade ...\nNaN\nNaN\nNaN\n\n\n1\n1990.4.21\n1990\n4\n21\n13\nNOR\nNorway\nNaN\nFevik\nNaN\n...\n600.0\nBeating/kicking\nSticks, chains, bats and beating/kicking\n0\n0\n5\nThe attack known as 'Fevik-slaget' occurred wh...\nNaN\nNaN\nNaN\n\n\n2\n1990.5.26\n1990\n5\n26\n16\nSWE\nSweden\nNaN\nMotala\nNaN\n...\nNaN\nNaN\nSmoke bomb\n0\n0\n11\n11 refugees were taken to the hospital after ...\nNaN\nNaN\nNaN\n\n\n3\n1990.5.30\n1990\n5\n30\n16\nSWE\nSweden\nVästra Götaland\nGothenburg\nNaN\n...\nNaN\nNaN\nTwo Molotov cocktails\n0\n0\n0\nTwo young men threw Molotov cocktails at the r...\nNaN\nNaN\nNaN\n\n\n4\n1990.5.d\n1990\n5\nd\n16\nSWE\nSweden\nNaN\nMellösa\nNaN\n...\nNaN\nNaN\nArson\n0\n0\n0\nAfter provoking a fight with a Roma family in ...\nNaN\nNaN\nNaN\n\n\n\n\n5 rows × 34 columns\n\n\n\n\n\n\n\nZeilen und Spalten löschen\nZum Löschen von einzelnen Spalten oder Zeilen können wir drop() verwenden.\n\nselection_df = df.drop(columns=['description', 'weapon_description'])\nselection_df.head()\n\n\n\n\n\n\n\n\n\ncase_id\nyear\nmonth\nday\ncountry_id\niso3\ncountry_name\nregion\ncity/village\nlocation\n...\nweapon_type\ngrouped_weapon_type\nweapon_type_2\ngrouped_weapon_type_2\nfatal\nn_killed\nn_wounded\nplot_type\nplot_targeting\nplot_operational_planning\n\n\n\n\n0\n1990.3.4\n1990\n3\n4\n13\nNOR\nNorway\nOslo\nOslo\nNaN\n...\n802\nOther\nNaN\nNaN\n0\n0\n0\nNaN\nNaN\nNaN\n\n\n1\n1990.4.21\n1990\n4\n21\n13\nNOR\nNorway\nNaN\nFevik\nNaN\n...\n500\nBlunt instruments\n600.0\nBeating/kicking\n0\n0\n5\nNaN\nNaN\nNaN\n\n\n2\n1990.5.26\n1990\n5\n26\n16\nSWE\nSweden\nNaN\nMotala\nNaN\n...\n806\nOther\nNaN\nNaN\n0\n0\n11\nNaN\nNaN\nNaN\n\n\n3\n1990.5.30\n1990\n5\n30\n16\nSWE\nSweden\nVästra Götaland\nGothenburg\nNaN\n...\n201\nArson/firebomb\nNaN\nNaN\n0\n0\n0\nNaN\nNaN\nNaN\n\n\n4\n1990.5.d\n1990\n5\nd\n16\nSWE\nSweden\nNaN\nMellösa\nNaN\n...\n200\nArson/firebomb\nNaN\nNaN\n0\n0\n0\nNaN\nNaN\nNaN\n\n\n\n\n5 rows × 32 columns\n\n\n\n\n Die Funktion drop_duplicates() löscht alle Zeilen, in denen sich die Werte wiederholen.\n\nwithout_duplicates_df = df.drop_duplicates(\n    subset=['country_name'],\n    keep='first',\n    # keep='first' behält den ersten Wert\n    # keep='last' behält den letzten Wert\n    # Keep=False löscht alle Dubletten\n)\nwithout_duplicates_df.head(2)\n\n\n\n\n\n\n\n\n\ncase_id\nyear\nmonth\nday\ncountry_id\niso3\ncountry_name\nregion\ncity/village\nlocation\n...\nweapon_type_2\ngrouped_weapon_type_2\nweapon_description\nfatal\nn_killed\nn_wounded\ndescription\nplot_type\nplot_targeting\nplot_operational_planning\n\n\n\n\n0\n1990.3.4\n1990\n3\n4\n13\nNOR\nNorway\nOslo\nOslo\nNaN\n...\nNaN\nNaN\nCS-gas\n0\n0\n0\nUnknown perpetrators threw a military grenade ...\nNaN\nNaN\nNaN\n\n\n2\n1990.5.26\n1990\n5\n26\n16\nSWE\nSweden\nNaN\nMotala\nNaN\n...\nNaN\nNaN\nSmoke bomb\n0\n0\n11\n11 refugees were taken to the hospital after ...\nNaN\nNaN\nNaN\n\n\n\n\n2 rows × 34 columns\n\n\n\n\n\n\n\nWerte ändern\nFür manche Operationen kann es nötig werden, den Datentyp einer Spalte oder Zeile zu ändern. In unserem Beispiel möchten wir sicherstellen, dass alle Werte der Spalte ‘year’ als String vorliegen und nicht numerisch sind. Mit der Funktion info() lassen wir uns zunächst anzeigen, welchen Typ die Daten in den verschiedenen Spalten haben. Mit astype() ändern wir anschließend den Datentyp.\n\ndf['country_id'].info()\nchanged_type_df = df\nchanged_type_df['country_id']=df['country_id'].astype('str')\nprint('\\n**** Der type int64 wird zu nach der Umwandlung zu object ****\\n')\nchanged_type_df['country_id'].info()\n\n&lt;class 'pandas.core.series.Series'&gt;\nRangeIndex: 2001 entries, 0 to 2000\nSeries name: country_id\nNon-Null Count  Dtype\n--------------  -----\n2001 non-null   int64\ndtypes: int64(1)\nmemory usage: 15.8 KB\n\n**** Der type int64 wird zu nach der Umwandlung zu object ****\n\n&lt;class 'pandas.core.series.Series'&gt;\nRangeIndex: 2001 entries, 0 to 2000\nSeries name: country_id\nNon-Null Count  Dtype \n--------------  ----- \n2001 non-null   object\ndtypes: object(1)\nmemory usage: 15.8+ KB\n\n\n Mit rename() lassen sich Spalten- und Zeilennamen ändern.\n\nrenamed_df = df.rename(columns = {'year':'Jahr'})\nrenamed_df.head(2)\n\n\n\n\n\n\n\n\n\ncase_id\nJahr\nmonth\nday\ncountry_id\niso3\ncountry_name\nregion\ncity/village\nlocation\n...\nweapon_type_2\ngrouped_weapon_type_2\nweapon_description\nfatal\nn_killed\nn_wounded\ndescription\nplot_type\nplot_targeting\nplot_operational_planning\n\n\n\n\n0\n1990.3.4\n1990\n3\n4\n13\nNOR\nNorway\nOslo\nOslo\nNaN\n...\nNaN\nNaN\nCS-gas\n0\n0\n0\nUnknown perpetrators threw a military grenade ...\nNaN\nNaN\nNaN\n\n\n1\n1990.4.21\n1990\n4\n21\n13\nNOR\nNorway\nNaN\nFevik\nNaN\n...\n600.0\nBeating/kicking\nSticks, chains, bats and beating/kicking\n0\n0\n5\nThe attack known as 'Fevik-slaget' occurred wh...\nNaN\nNaN\nNaN\n\n\n\n\n2 rows × 34 columns",
    "crumbs": [
      "Startseite",
      "Daten vorbereiten",
      "Datensatz bereinigen"
    ]
  },
  {
    "objectID": "quellen.html",
    "href": "quellen.html",
    "title": "Quellen",
    "section": "",
    "text": "Datensatz\nRTV Datensatz\n\n\n\nPython\nrealpython Installationsguide\nJupyter/ Anaconda YouTube Tutorial\nw3school python documentation\nPython YouTube Tutorial\n\n\n\nDatenverarbeitung\nOpenRefine\nw3school pandas documentation\nrealpython Einführung in pandas Joins\n\n\n\nVisualisierung\nmatplotlib Dokumentation\nCairo, Alberto: The Functional Art. An introduction to information graphics and visualization, Voices That Matter, 2012.\nCairo, Alberto: The Truthful Art. Data, Charts, and Maps for Communication, Voices That Matter, 2016.\nClassen, Lew: Mit Jupyter durchs Physikpraktikum, Wiesbaden, 2022.\nEvergreen, Stephanie D.H.: The Data Visualization Sketchbook, Los Angeles (u.a.) 2020.\nLisnic, Maxim(u.a.): Misleading Beyond Visual Tricks: How People Actually Lie with Charts, Hamburg 2023.\nRahm, Erhard; Hong Hai Do: Data Cleaning: Problems and Current Approaches in: Bulletin of the Technical Committee on Data Engineering, Vol. 23, Nr. 4, 2000. https://tc.computer.org/tcde/data-engineering-bulletin/ (letzter Zugriff Juli 2024)\nSegel, Edward; Heer, Jeffrey: Narrative Visualization: Telling Stories with Data, in: IEEE Transactions on Visualization and Computer Graphics, Vol. 16, Nr. 6, 2010.\nWilke, Claus O.: Fundamentals of Data Visualization. A Primer on Making Informative and Compelling Figures, O’Reilly Media, 2019."
  },
  {
    "objectID": "sortieren.html",
    "href": "sortieren.html",
    "title": "Datensätze verbinden",
    "section": "",
    "text": "In diesem Abschnitt steigen wir in die fortgeschrittene Datenverarbeitung ein. Die Verbindung von Datensätzen in pandas erfolgt nach zwei unterschiedlichen Prinzipien. Entweder können wir die Daten unseres ersten Datensatzes auf die Daten unseres zweiten Datensatzes mappen. Oder wir hängen die Daten des ersten Datensatzes an den zweiten an. Dabei stehen zwei Richtungen zur Verfügung: horizontal (axis=1) und vertikal (axis=0). Die Funktionen merge() mappt die Daten horizontal. Die Funktion concat() hängt die Daten aneinander an. Das kann sie sowohl horizontal als auch vertikal.\nAnfangs kann es verwirrend sein, dass horizontale und vertikale Zusammenführung nicht derselben Logik folgen. Während wir mit einem horizontalen merge() in die Struktur der Datensätze eingreifen, hängen wir mit concat() die Datensätze lediglich aneinander an. Eine umfangreiche Dokumentation zu diesem Thema findet sich auf der Website realpython.\n\n\nVerbindungslogik\nAus SQL ist die folgende Verbindungslogik bekannt, die auch bei pandas zur Anwendung kommt, wir sollten sie uns daher gut einprägen:\n\nInner Join liefert einen Dataframe zurück, der lediglich die Daten enthält, die in beiden Datensätzen identisch vorhanden sind. Outer Join dagegen liefert alle Daten zurück. Dadurch entsteht eine Tabelle, die alle Spalten aus beiden Datensätzen enthält. Wenn ein Wert aus dem ersten Datensatz nicht auf den zweiten gemappt werden kann, wird diese Stelle in der Tabelle mit einem NaN-Wert gefüllt. Left und Right Join behalten jeweils einen Teil der Daten und verfahren im Übrigen wie Outer Join.\n\n\n\nHorizontale Verflechtung\nDie Funktion merge() mappt die Daten des ersten Datensatzes auf die Daten des zweiten. Die “kleine Schwester” von merge() ist die Funktion join(). Diese Funktion ist weniger mächtig, reicht aber für viele Zwecke bereits aus.\n\nimport pandas as pd\n# Erstellen zweier Beispieldatensätze:\nmy_df1 = pd.DataFrame({\n    'nummer': [1, 2, 3, 4],\n    'value': ['Apple', 'Orange', 'Lemon', 'Banana'],\n    'equal_column': ['A', 'B', 'C', 'D'],\n    'df1_column': [7, 8, 9, 10]\n\n})\n\nmy_df2 = pd.DataFrame({\n    'nummer': [1, 1, 2, 3],\n    'value': ['Apple', 'Orange', 'Pear', 'Banana' ],\n    'equal_column': ['A', 'B', 'C', 'D'],\n    'df2_column': [7, 8, 9, 10]\n})\n\nmy_df1.merge(my_df2)\n\n\n\n\n\n\n\n\n\nnummer\nvalue\nequal_column\ndf1_column\ndf2_column\n\n\n\n\n0\n1\nApple\nA\n7\n7\n\n\n\n\n\n\n\n\n Wie wir sehen, liefert die Funktion einen Dataframe zurück, der nur aus einer einzigen Zeile besteht: die Zeile, in der die Werte identisch sind, denn per default verbindet die Funktion merge() zwei Datensätze als Inner Join. Wir können der Funktion merge() aber auch mitteilen, anhand welcher Spalte sie unsere Dataframes verbinden soll.\n\nmy_df1.merge(my_df2, on= 'nummer')\n\n\n\n\n\n\n\n\n\nnummer\nvalue_x\nequal_column_x\ndf1_column\nvalue_y\nequal_column_y\ndf2_column\n\n\n\n\n0\n1\nApple\nA\n7\nApple\nA\n7\n\n\n1\n1\nApple\nA\n7\nOrange\nB\n8\n\n\n2\n2\nOrange\nB\n8\nPear\nC\n9\n\n\n3\n3\nLemon\nC\n9\nBanana\nD\n10\n\n\n\n\n\n\n\n\n\nNun sehen wir, dass wir einen Dataframe zurückgeliefert bekommen, der doppelte Werte enthält. Die ‘nummer’ mit Wert ‘1’ ist zwei Mal vorhanden, da jede der Spalten aus my_df1 auf die Spalten des my_df2 gemappt wurde. Pandas hängt an die Spaltennamen, die in den Dataframes identisch sind, ein _x und _y an. Diese default Werte können wir anpassen, indem wir den Parameter suffixes=['my_suffix1', 'my_suffix2'] übergeben.\nAls nächstes verbinden wir unsere Dataframes mit einem Outer Join und sehen, dass die Stellen in der Tabelle, für die keine übereinstimmenden Daten gefunden werden können, mit NaN-Werten gefüllt werden.\n\nmy_df1.merge(my_df2, on= 'nummer', how='outer')\n\n\n\n\n\n\n\n\n\nnummer\nvalue_x\nequal_column_x\ndf1_column\nvalue_y\nequal_column_y\ndf2_column\n\n\n\n\n0\n1\nApple\nA\n7\nApple\nA\n7.0\n\n\n1\n1\nApple\nA\n7\nOrange\nB\n8.0\n\n\n2\n2\nOrange\nB\n8\nPear\nC\n9.0\n\n\n3\n3\nLemon\nC\n9\nBanana\nD\n10.0\n\n\n4\n4\nBanana\nD\n10\nNaN\nNaN\nNaN\n\n\n\n\n\n\n\n\n\n\n\nVertikale und horizontale Verkettung\nDie Funktion concat() kann Daten sowohl vertikal (axis=0, per default) als auch horizontal (axis=1) verketten. Der Unterschied zu merge() ist jedoch, dass die Daten lediglich angehängt werden. Auch concat() hat eine weniger mächtige “kleine Schwester”, die Funktion append().\nDie Funktion concat() konkateniert zwei Dataframes. Sie erweitert also unsere Tabelle und hängt den zweiten Dataframe an den ersten an.\n\n# durch ignore_index=True wird der Index neu gesetzt\npd.concat([my_df1, my_df2], ignore_index=True)\n\n\n\n\n\n\n\n\n\nnummer\nvalue\nequal_column\ndf1_column\ndf2_column\n\n\n\n\n0\n1\nApple\nA\n7.0\nNaN\n\n\n1\n2\nOrange\nB\n8.0\nNaN\n\n\n2\n3\nLemon\nC\n9.0\nNaN\n\n\n3\n4\nBanana\nD\n10.0\nNaN\n\n\n4\n1\nApple\nA\nNaN\n7.0\n\n\n5\n1\nOrange\nB\nNaN\n8.0\n\n\n6\n2\nPear\nC\nNaN\n9.0\n\n\n7\n3\nBanana\nD\nNaN\n10.0\n\n\n\n\n\n\n\n\n\nWir können die Funktion concat() auch mit einem Inner Join verwenden, dadurch werden nur die Zeilen und Spalten zurückgeliefert, für die identische Werte in beiden Dataframes existieren.\n\npd.concat([my_df1, my_df2], join='inner', ignore_index=True)\n\n\n\n\n\n\n\n\n\nnummer\nvalue\nequal_column\n\n\n\n\n0\n1\nApple\nA\n\n\n1\n2\nOrange\nB\n\n\n2\n3\nLemon\nC\n\n\n3\n4\nBanana\nD\n\n\n4\n1\nApple\nA\n\n\n5\n1\nOrange\nB\n\n\n6\n2\nPear\nC\n\n\n7\n3\nBanana\nD\n\n\n\n\n\n\n\n\n\nWir können eine merge ähnliche Ansicht durch die horizontale Verkettung erwirken, aber auch hier werden die Daten lediglich angehängt und nicht gemapped.\n\npd.concat([my_df1, my_df2], axis=1)\n\n\n\n\n\n\n\n\n\nnummer\nvalue\nequal_column\ndf1_column\nnummer\nvalue\nequal_column\ndf2_column\n\n\n\n\n0\n1\nApple\nA\n7\n1\nApple\nA\n7\n\n\n1\n2\nOrange\nB\n8\n1\nOrange\nB\n8\n\n\n2\n3\nLemon\nC\n9\n2\nPear\nC\n9\n\n\n3\n4\nBanana\nD\n10\n3\nBanana\nD\n10\n\n\n\n\n\n\n\n\n\n\n\nFunktionale Programmierung verwenden\nIn unserem Beispiel möchten wir nun einen demographischen Datensatz (df2) mit unserem Right-Wing-Terrorism and Violence-Dataset (df1) verbinden. Wir möchten noch eine weitere Spalte an die Tabelle anfügen, die für jedes Jahr und für jedes Land die entsprechende Einwohnerzahl auflistet.\nSchauen wir uns zunächst beide Datensätze an:\n\nimport pandas as pd\ndf1 = pd.read_excel('2023-rtv-1990-2022_without-sources.xlsx')\n# die Daten im zweiten Datensatz liegen als Tab Separated Value vor. Diese Information geben wir beim Einlesen an.\ndf2 = pd.read_csv('democraphics_2014-2023.tsv', sep='\\t') \ndf2.head()\n\n\n\n\n\n\n\n\n\ngeo\n2014\n2015\n2016\n2017\n2018\n2019\n2020\n2021\n2022\n2023\n\n\n\n\n0\nAustria\n8507786\n8584926\n8700471\n8772865\n8822267\n8858775\n8901064\n8932664\n8978929\n9104772\n\n\n1\nBelgium\n11180840\n11237274\n11311117\n11351727\n11398589\n11455519\n11522440\n11554767\n11617623\n11742796\n\n\n2\nSwizerland\n8139631\n8237666\n8327126\n8419550\n8484130\n8544527\n8606033\n8670300\n8738791\n8815385\n\n\n3\nGermany\n80767463\n81197537\n82175684\n82521653\n82792351\n83019213\n83166711\n83155031\n83237124\n84358845\n\n\n4\nDenmark\n5627235\n5659715\n5707251\n5748769\n5781190\n5806081\n5822763\n5840045\n5873420\n5932654\n\n\n\n\n\n\n\n\n Offensichtlich lassen sich die beiden Datensätze sehr gut über die Spalten ‘country_name’ (df1) und ‘geo’ (df2) verbinden, denn hier besitzen sie identische Werte.\n\n# die Werte von df2 sollen nun als neue Spalten rechts an die bestehende Tabelle angehängt werden.\nmerged_df = pd.merge(df1, df2, left_on='country_name', right_on='geo', how='inner')\n# Mit Hilfe einer Funktion spezifizieren wir: greife nur auf diejenigen Werte in df2 zu, \n# für die in der Spalte 'year' aus df1 ein identischer Wert gefunden wurde.\n# Die Zeilen, für die kein Wert gefunden wurde, werden mit 'None' gefüllt.\ndef get_mapped_value(row):\n    column_name = str(row['year'])  # Jahr in String umwandeln, um Spaltennamen abzugleichen\n    if column_name in row:\n        return row[column_name]\n    else:\n        return None\n\n# mit dem Parameter 'axis=1' geben wir an, dass die Werte Reihenweise gemappt werden sollen.\n# 'axis=0' würde dagegen die Spalten mappen.\n# anschließend wenden wir die Funktion auf jede Zeile an, \n# um die neue Spalte 'mapped_population' zu erstellen\nmerged_df['mapped_population'] = merged_df.apply(get_mapped_value, axis=1)\n\n# Unnötige Spalten entfernen\nmerged_df.drop(columns=['geo'] + [str(year) for year in range(2014, 2024)], inplace=True)\nmerged_df.tail()\n\n\n\n\n\n\n\n\n\ncase_id\nyear\nmonth\nday\ncountry_id\niso3\ncountry_name\nregion\ncity/village\nlocation\n...\ngrouped_weapon_type_2\nweapon_description\nfatal\nn_killed\nn_wounded\ndescription\nplot_type\nplot_targeting\nplot_operational_planning\nmapped_population\n\n\n\n\n1961\n2021-6-21\n2021\n6\n21\n2\nBEL\nBelgium\nFlanders\nMaasmechelen\nHoge Kempen National Park\n...\nExplosives\nWeapons including a machine gun, a rocket laun...\n0\n0\n0\nCOVID-19 related. A 46-year-old Belgian soldie...\n3.0\n3.0\n3.0\n11554767\n\n\n1962\n2022-9-28\n2022\n9\n28\n2\nBEL\nBelgium\nFlanders\nMultiple locations\nMultiple locations\n...\nNaN\n100 firearms and a large quantity of ammunition\n0\n0\n0\nPolice searched a dozen houses and arrested si...\nNaN\nNaN\nNaN\n11617623\n\n\n1963\n2018-2-18\n2018\n2\n18\n11\nLUX\nLuxembourg\nLuxembourg\nEsch-sur-Alzette\nRue des Remparts\n...\nNaN\nKnife\n0\n0\n1\nAccording to witnesses, a man addressed severa...\nNaN\nNaN\nNaN\n602005\n\n\n1964\n2020-2-22\n2020\n2\n22\n11\nLUX\nLuxembourg\nLuxembourg\nStrassen\nRue des Romains\n...\nNaN\nMaterial to produce explosives\n0\n0\n0\nAn 18-year-old man was arrested after foreign ...\n3.0\n6.0\n3.0\n626108\n\n\n1965\n2022-9-23\n2022\n9\n23\n8\nISL\nIceland\nHöfuðborgarsvæðið\nMultiple locations\nMultiple locations\n...\nNaN\nFirearms, including semi-automatic guns, a tho...\n0\n0\n0\nFour right-wing extremists were arrested on su...\n3.0\n5.0\n2.0\n376248\n\n\n\n\n5 rows × 35 columns\n\n\n\n\n Mit Hilfe einer lambda-Funktion verkürzt sich die Syntax noch einmal erheblich und wird übersichtlicher:\n\nmerged_df = pd.merge(df1, df2, left_on='country_name', right_on='geo', how='inner')\n# lamda\nmerged_df['mapped_value'] = merged_df.apply(lambda row: row[str(row['year'])] if str(row['year']) in merged_df.columns else None, axis=1)\n\n\nZuletzt können wir uns noch dafür entscheiden die Spalte ‘geo’ aus unserem ‘df2’ zu behalten, um unseren Dataframe übersichtlicher zu machen. In diesem Fall löschen wir alle Spalten aus ‘df2’, außer der ersten.\n\n# Alle Spalten aus 'df2' außer der ersten löschen\nmerged_df.drop(columns=df2.columns[1:], inplace=True)\nmerged_df.tail()\n\n\n\n\n\n\n\n\n\ncase_id\nyear\nmonth\nday\ncountry_id\niso3\ncountry_name\nregion\ncity/village\nlocation\n...\nweapon_description\nfatal\nn_killed\nn_wounded\ndescription\nplot_type\nplot_targeting\nplot_operational_planning\ngeo\nmapped_value\n\n\n\n\n1961\n2021-6-21\n2021\n6\n21\n2\nBEL\nBelgium\nFlanders\nMaasmechelen\nHoge Kempen National Park\n...\nWeapons including a machine gun, a rocket laun...\n0\n0\n0\nCOVID-19 related. A 46-year-old Belgian soldie...\n3.0\n3.0\n3.0\nBelgium\n11554767\n\n\n1962\n2022-9-28\n2022\n9\n28\n2\nBEL\nBelgium\nFlanders\nMultiple locations\nMultiple locations\n...\n100 firearms and a large quantity of ammunition\n0\n0\n0\nPolice searched a dozen houses and arrested si...\nNaN\nNaN\nNaN\nBelgium\n11617623\n\n\n1963\n2018-2-18\n2018\n2\n18\n11\nLUX\nLuxembourg\nLuxembourg\nEsch-sur-Alzette\nRue des Remparts\n...\nKnife\n0\n0\n1\nAccording to witnesses, a man addressed severa...\nNaN\nNaN\nNaN\nLuxembourg\n602005\n\n\n1964\n2020-2-22\n2020\n2\n22\n11\nLUX\nLuxembourg\nLuxembourg\nStrassen\nRue des Romains\n...\nMaterial to produce explosives\n0\n0\n0\nAn 18-year-old man was arrested after foreign ...\n3.0\n6.0\n3.0\nLuxembourg\n626108\n\n\n1965\n2022-9-23\n2022\n9\n23\n8\nISL\nIceland\nHöfuðborgarsvæðið\nMultiple locations\nMultiple locations\n...\nFirearms, including semi-automatic guns, a tho...\n0\n0\n0\nFour right-wing extremists were arrested on su...\n3.0\n5.0\n2.0\nIceland\n376248\n\n\n\n\n5 rows × 36 columns",
    "crumbs": [
      "Startseite",
      "Daten vorbereiten",
      "Datensätze verbinden"
    ]
  },
  {
    "objectID": "ueberblick.html",
    "href": "ueberblick.html",
    "title": "Datensatz sortieren",
    "section": "",
    "text": "Die einfachste Sortierung, die ein Datensatz haben kann, ist sein Index. Pandas generiert automatisch einen Index für alle Zeilen der Tabelle in aufsteigender Reihenfolge. Meist folgen die Daten in einem Datensatz zusätzlich einer bestimmten Sortierlogik, in unserem Beispiel sind sie chronologisch geordnet. Mit pandas können wir nicht nur neue Sortierkriterien festlegen, sondern auch bestimmte Teilbereiche eines Datensatzes gruppieren oder aussortieren.",
    "crumbs": [
      "Startseite",
      "Daten vorbereiten",
      "Datensatz sortieren"
    ]
  },
  {
    "objectID": "ueberblick.html#daten-auswählen",
    "href": "ueberblick.html#daten-auswählen",
    "title": "Datensatz sortieren",
    "section": "Daten auswählen",
    "text": "Daten auswählen\nWollen wir aus unseren Daten nur bestimmte Spalten oder Zeilen auswählen oder die Bereiche beschränken, auf denen wir unsere Operationen ausführen, können wir diese aus dem Dataframe separieren.\n\n# pandas laden und Datensatz einlesen\nimport pandas as pd\ndf = pd.read_excel('2023-rtv-1990-2022_without-sources.xlsx')\n\n\n# doppelte Klammern [[]] sorgen dafür, dass ein Dataframe zurückgeliefert wird\n# mit einfachen Klammern [] würden wir eine Serie zurückerhalten\nfiltered_df = df[['country_name']]\nfiltered_df.head()\n\n\n\n\n\n\n\n\n\ncountry_name\n\n\n\n\n0\nNorway\n\n\n1\nNorway\n\n\n2\nSweden\n\n\n3\nSweden\n\n\n4\nSweden\n\n\n\n\n\n\n\n\n Wir können festlegen, nach welchen Kriterien bestimmt Bereiche eines Dataframe aussortiert werden sollen. Mit logischen Operatoren können wir mehrere Kriterien verknüpfen. In unserem Beispiel separieren wir alle Daten aus Deutschland vor dem Jahrtausendwechsel.\n\ngermany_bevor2000_df = df[(df['country_name']=='Germany') & (df['year']&lt;2000)]\n\ngermany_bevor2000_df.tail()\n\n\n\n\n\n\n\n\n\ncase_id\nyear\nmonth\nday\ncountry_id\niso3\ncountry_name\nregion\ncity/village\nlocation\n...\nweapon_type_2\ngrouped_weapon_type_2\nweapon_description\nfatal\nn_killed\nn_wounded\ndescription\nplot_type\nplot_targeting\nplot_operational_planning\n\n\n\n\n214\n1999-8-9\n1999\n8\n9\n6\nDEU\nGermany\nNiedersachsen\nEschede\nm\n...\nNaN\nNaN\nBeating/kicking\n1\n1\n0\nTwo skinheads, aged 17 and 18, who had been d...\nNaN\nNaN\nNaN\n\n\n215\n1999-8-15\n1999\n8\n15\n6\nDEU\nGermany\nBavaria\nKolbermoor\nBus stop near Schuhmannstraße\n...\nNaN\nNaN\nBeating/kicking\n1\n1\n0\nThe 31-year old perpetrator was upset that his...\nNaN\nNaN\nNaN\n\n\n217\n1999-10-1\n1999\n10\n1\n6\nDEU\nGermany\nSachsen\nHohenstein-Ernstthal\nm\n...\nNaN\nNaN\nAxe handle and pool cue stick\n1\n1\n0\nThe victim and his friend were ambushed on the...\nNaN\nNaN\nNaN\n\n\n218\n1999-10-8\n1999\n10\n8\n6\nDEU\nGermany\nSachsen-Anhalt\nLöbejün\nm\n...\n800.0\nOther\nBeating/kicking and drowning\n1\n1\n0\nThe victim, who was mentally disabled, was tor...\nNaN\nNaN\nNaN\n\n\n222\n1999-12-29\n1999\n12\n29\n6\nDEU\nGermany\nSachsen-Anhalt\nHalle\nNeustadt\n...\nNaN\nNaN\nBeating/kicking\n1\n1\n0\nA mentally disabled 39-year-old man was beaten...\nNaN\nNaN\nNaN\n\n\n\n\n5 rows × 34 columns\n\n\n\n\n Mit der Methode isin() können wir ebenfalls mehrere Auswahlkriterien miteinander verknüpfen. In unserem Beispiel die Jahre 1990 und 2015.\n\nsome_years_df = df[df['year'].isin([1990, 2015])]\nsome_years_df.head(2)\n\n\n\n\n\n\n\n\n\ncase_id\nyear\nmonth\nday\ncountry_id\niso3\ncountry_name\nregion\ncity/village\nlocation\n...\nweapon_type_2\ngrouped_weapon_type_2\nweapon_description\nfatal\nn_killed\nn_wounded\ndescription\nplot_type\nplot_targeting\nplot_operational_planning\n\n\n\n\n0\n1990-3-4\n1990\n3\n4\n13\nNOR\nNorway\nOslo\nOslo\nNaN\n...\nNaN\nNaN\nCS-gas\n0\n0\nm\nUnknown perpetrators threw a military grenade ...\nNaN\nNaN\nNaN\n\n\n1\n1990-4-21\n1990\n4\n21\n13\nNOR\nNorway\nNaN\nFevik\nNaN\n...\n600.0\nBeating/kicking\nSticks, chains, bats and beating/kicking\n0\n0\n5\nThe attack known as 'Fevik-slaget' occurred wh...\nNaN\nNaN\nNaN\n\n\n\n\n2 rows × 34 columns\n\n\n\n\n Weitere Funktionen zum Auswählen von Teilbereichen unserer Daten sind loc[ ] und iloc[ ]. Wobei loc[ ] als Parameter einen Wert aus dem Dataframe erwartet und iloc[ ] einen Index. Dabei verhält sich die Selektion mit iloc[ ] wie aus Python bekannt so, dass der Zielindex nicht in der Ergebnismenge enthalten ist. iloc[1:3] liefert also Index 1 und 2. Dagegen sind bei loc[‘1990’:‘2000’] die 2000er Jahre im Ergebnis enthalten. Da es sich um ein Subset einer bestehenden Menge handelt, müssen wir hier eckige Klammern verwenden.\n\nsubset_df = df.iloc[1:3] \nsubset_df.head()\n\n\n\n\n\n\n\n\n\ncase_id\nyear\nmonth\nday\ncountry_id\niso3\ncountry_name\nregion\ncity/village\nlocation\n...\nweapon_type_2\ngrouped_weapon_type_2\nweapon_description\nfatal\nn_killed\nn_wounded\ndescription\nplot_type\nplot_targeting\nplot_operational_planning\n\n\n\n\n1\n1990-4-21\n1990\n4\n21\n13\nNOR\nNorway\nNaN\nFevik\nNaN\n...\n600.0\nBeating/kicking\nSticks, chains, bats and beating/kicking\n0\n0\n5\nThe attack known as 'Fevik-slaget' occurred wh...\nNaN\nNaN\nNaN\n\n\n2\n1990-5-26\n1990\n5\n26\n16\nSWE\nSweden\nNaN\nMotala\nNaN\n...\nNaN\nNaN\nSmoke bomb\n0\n0\n11\n11 refugees were taken to the hospital after ...\nNaN\nNaN\nNaN\n\n\n\n\n2 rows × 34 columns",
    "crumbs": [
      "Startseite",
      "Daten vorbereiten",
      "Datensatz sortieren"
    ]
  },
  {
    "objectID": "ueberblick.html#daten-gruppieren",
    "href": "ueberblick.html#daten-gruppieren",
    "title": "Datensatz sortieren",
    "section": "Daten gruppieren",
    "text": "Daten gruppieren\nUm Operationen nur auf einem bestimmten Teil unserer Daten auszuführen können wir unseren Dataframe gruppieren. Dazu stellt uns pandas die Funktion groupby() zur Verfügung. In unserem Beispiel groupieren wir nach ‘country_name’ und, darauf basierend, auf ‘grouped_target_group’ und führen anschließend die Operation size() auf dieser Gruppierung aus um zu erfahren, wie häufig eine target_group pro Land auftaucht. Das Ergebnis weisen wir in einem neuen Dataframe zu (occurrence_count).\n\noccurrence_count= df.groupby(['country_name', 'grouped_target_group']).size()\n\noccurrence_count.head(20)\n\ncountry_name  grouped_target_group       \nAustria       Ethnic/religious minorities    12\n              Other                           2\n              Political opponents            24\n              State institutions              3\n              Unknown                        10\nBelgium       Ethnic/religious minorities    18\n              State institutions              4\n              Unknown                         1\nDenmark       Ethnic/religious minorities    20\n              Marginalized groups             1\n              Political opponents             7\n              Unknown                         2\nFinland       Ethnic/religious minorities    14\n              Marginalized groups             2\n              Other                           1\n              Political opponents             3\n              Unknown                         2\nFrance        Ethnic/religious minorities    59\n              Marginalized groups             1\n              Other                           3\ndtype: int64\n\n\n Die groupby() Funktion eignet sich auch dazu, eine numerische Darstellung aus nichtnumerischen Daten zu gewinnen. In geisteswissenschaftlichen Forschungskontexten begegnen wir häufig nichtnumerischen Werten. Um numerische Daten aus ihnen abzuleiten können wir sie nach Gleichheit gruppieren, anschließend akkumulieren wir die gleichen Werte mit count() und lassen uns das Ergebnis ausgeben.\n\ndf.groupby('country_name').count()\n\n\n\n\n\n\n\n\n\ncase_id\nyear\nmonth\nday\ncountry_id\niso3\nregion\ncity/village\nlocation\nlocation_latitude\n...\nweapon_type_2\ngrouped_weapon_type_2\nweapon_description\nfatal\nn_killed\nn_wounded\ndescription\nplot_type\nplot_targeting\nplot_operational_planning\n\n\ncountry_name\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAustria\n51\n51\n51\n51\n51\n51\n28\n51\n29\n19\n...\n13\n13\n51\n51\n51\n51\n51\n4\n4\n4\n\n\nBelgium\n23\n23\n23\n23\n23\n23\n21\n23\n20\n16\n...\n6\n6\n23\n23\n23\n23\n23\n5\n5\n5\n\n\nDenmark\n30\n30\n30\n30\n30\n30\n13\n30\n12\n11\n...\n9\n9\n30\n30\n30\n30\n30\n0\n0\n0\n\n\nFinland\n22\n22\n22\n22\n22\n22\n21\n22\n20\n18\n...\n7\n7\n22\n22\n22\n22\n22\n2\n2\n2\n\n\nFrance\n102\n102\n102\n102\n102\n102\n99\n102\n92\n83\n...\n34\n34\n102\n102\n102\n102\n102\n12\n12\n12\n\n\nGermany\n653\n653\n653\n653\n653\n653\n623\n653\n609\n571\n...\n149\n149\n653\n653\n653\n653\n653\n33\n33\n33\n\n\nGreece\n178\n178\n178\n178\n178\n178\n178\n178\n177\n177\n...\n77\n77\n178\n178\n178\n178\n178\n1\n1\n1\n\n\nIceland\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n...\n0\n0\n1\n1\n1\n1\n1\n1\n1\n1\n\n\nIreland\n14\n14\n14\n14\n14\n14\n13\n14\n13\n13\n...\n3\n3\n14\n14\n14\n14\n14\n0\n0\n0\n\n\nItaly\n255\n255\n255\n255\n255\n255\n204\n255\n217\n198\n...\n89\n89\n255\n255\n255\n255\n255\n8\n8\n8\n\n\nLuxembourg\n2\n2\n2\n2\n2\n2\n2\n2\n2\n1\n...\n0\n0\n2\n2\n2\n2\n2\n1\n1\n1\n\n\nNetherlands\n19\n19\n19\n19\n19\n19\n14\n19\n12\n11\n...\n3\n3\n19\n19\n19\n19\n19\n2\n2\n2\n\n\nNorway\n60\n60\n60\n60\n60\n60\n42\n60\n34\n23\n...\n11\n11\n60\n60\n60\n60\n60\n2\n2\n2\n\n\nPortugal\n18\n18\n18\n18\n18\n18\n18\n18\n17\n17\n...\n6\n6\n18\n18\n18\n18\n18\n0\n0\n0\n\n\nSpain\n150\n150\n150\n150\n150\n150\n138\n150\n139\n134\n...\n40\n40\n150\n150\n150\n150\n150\n4\n4\n4\n\n\nSweden\n137\n137\n137\n137\n137\n137\n110\n137\n91\n76\n...\n34\n34\n137\n137\n137\n137\n137\n7\n7\n7\n\n\nSwitzerland\n13\n13\n13\n13\n13\n13\n12\n13\n12\n8\n...\n2\n2\n13\n13\n13\n13\n13\n2\n2\n2\n\n\nUnited Kingdom\n273\n273\n273\n273\n273\n273\n258\n273\n247\n227\n...\n63\n63\n273\n273\n273\n273\n273\n30\n30\n30\n\n\n\n\n18 rows × 33 columns\n\n\n\n\n Pandas stellt uns auch die Funktion unique() bereit. Sie listet die einmaligen Werte in einer Spalte und nunique() gibt die Anzahl der einmaligen Werte aus. Für unseren Datensatz können wir somit feststellen, dass Daten aus 18 verschiedenen Ländern über 33 Jahre hinweg erhoben wurden.\n\ndf.nunique().head()\n\ncase_id       2001\nyear            33\nmonth           13\nday             32\ncountry_id      18\ndtype: int64\n\n\n value_counts() liefert die Häufigkeit aller Werte in einer Spalte zurück. In unserem Beispiel möchten wir für die Spalte grouped_target_group wissen, welche unterschiedlichen Opfergruppen im Datensatz existieren und wie häufig sie vorkommen.\n\ndf['grouped_target_group'].value_counts()\n\ngrouped_target_group\nEthnic/religious minorities    1322\nPolitical opponents             420\nUnknown                          95\nMarginalized groups              81\nState institutions               62\nOther                            21\nName: count, dtype: int64",
    "crumbs": [
      "Startseite",
      "Daten vorbereiten",
      "Datensatz sortieren"
    ]
  },
  {
    "objectID": "ueberblick.html#sortierung-ändern",
    "href": "ueberblick.html#sortierung-ändern",
    "title": "Datensatz sortieren",
    "section": "Sortierung ändern",
    "text": "Sortierung ändern\nUm die Sortierung unserer Daten zu ändern, haben wir verschiedene sort() Funktionen zur Verfügung. In unserem Beispiel sortieren wir die Werte mit sort_values(). Wir können der Funktion Parameter übergeben um unser Anliegen zu spezifizieren.\n\nsorted_df = df.sort_values(\n    by=['country_name'], # Spalten angeben, nach denen sortiert werden soll\n    ascending=True, # auf- oder absteigend sortieren\n    ignore_index=True, # den Index neu setzen\n)\nsorted_df.head()\n\n\n\n\n\n\n\n\n\ncase_id\nyear\nmonth\nday\ncountry_id\niso3\ncountry_name\nregion\ncity/village\nlocation\n...\nweapon_type_2\ngrouped_weapon_type_2\nweapon_description\nfatal\nn_killed\nn_wounded\ndescription\nplot_type\nplot_targeting\nplot_operational_planning\n\n\n\n\n0\n2021-11-14\n2021\n11\n14\n1\nAUT\nAustria\nSalzburg\nSalzburg\nMaxglan\n...\n801.0\nOther\nPepper spray, car and beating/kicking\n0\n0\n0\nThe 26-year-old perpetrator racially insulted ...\nNaN\nNaN\nNaN\n\n\n1\n2017-2-3\n2017\n2\n3\n1\nAUT\nAustria\nWien\nVienna\nm\n...\nNaN\nNaN\n7.65mm pistol\n0\n0\n0\nA German soldier was arrested on suspicion of ...\n2.0\n6.0\n2.0\n\n\n2\n1993-12-3\n1993\n12\n3\n1\nAUT\nAustria\nNaN\nHartberg\nNaN\n...\nNaN\nNaN\nLetter bomb\n0\n0\n1\nA Roman Catholic priest was targeted in the fi...\nNaN\nNaN\nNaN\n\n\n3\n2021-11-16-a\n2021\n11\n16\n1\nAUT\nAustria\nMultiple locations\nMultiple locations\nMultiple locations\n...\n302.0\nFirearms\nAt least 20 rifles, handguns and other firearm...\n0\n0\n0\nDuring the course of house raids in right-wing...\nNaN\nNaN\nNaN\n\n\n4\n1997-10-1\n1997\n10\n1\n1\nAUT\nAustria\nNaN\nGralla\nNaN\n...\nNaN\nNaN\nImprovised explosive device\n0\n0\n1\nThe perpetrator detonated an IED he kept in hi...\nNaN\nNaN\nNaN\n\n\n\n\n5 rows × 34 columns",
    "crumbs": [
      "Startseite",
      "Daten vorbereiten",
      "Datensatz sortieren"
    ]
  }
]